:- initialize.
:- needs_gr($(lib)/nat/nat).
:- needs_gr($(examples)/alpha/code).
:- tex_file($(tmp)/alpha).
:- needs_thm($(tmp)/valueaxioms).
:- needs_thm($(lib)/nat/nat).

/** Documentation for the proof of equivalence
      between min_max/3 and alpha_beta/5 */

/** Abstract */

/** The field of problems where algorithms like <TT>min_max/3</TT> and the 
efficiently implemented version <TT>alpha_beta/5</TT> are used, are the 
two-person, perfect-information games, such as chess and go.
In such games there are two players which make moves alternatively, and both
players have the complete information of the game. The possible moves in a
current situation obey certain rules that do not concern us much. We assume 
only, that the function <TT>moves/2</TT> returns us a list of positions.
Because we are interested in the evaluation of a situation, and not on
the outcome of the game, we do not need the best move specially. The 
fact that values determine the possible moves is enough.
When a game is won, lost or draw depends on the rules of the game, so
this problem can be forgotten for the moment.
In other words we are only interested in the <TT>game tree</TT> represented
by the described problem. The initial situation of the game is the root node,
the arcs correspond to moves and the leaves correspond to the situation 
when <TT>moves/2</TT> returns an empty list of moves. It means when the 
algorithm has finished or terminated computing.
As it is a two-person game one has to begin the other to answer. One part 
takes the computer, in fact the programmer, that means
'us'. The other part takes a person playing against 'us', we call 'them'. 
The <TT>game tree</TT> described by these rules is a <TT>AND/OR tree</TT>.
When they have to play ('them' are to move), they have the choice, taking 
any move in the list. We do not know which one they take, so we have to 
consider and evaluate each possible move. To evaluate the situation
we have to find the move with the minimum of possible evaluations. In
the best case it is -infinity (in the prolog code the value bot and a). 
This leads to an <TT>AND node</TT> in the game tree. 
When we have to play we have also a choice, but we have exactly one 
possible move. So we have to take that move with the maximum of possible
evaluations. Best case is +infinity (value top or b in the prolog code).
This leads to an <TT>OR node</TT> in the game tree.
Our task consisted of implementing both algorithms mentioned at the 
beginning and proving the equivalence of them with <TT>LPTP</TT>. */

/** Minimax principle */

/** Computing the whole game tree with all its repetitions and situations
is beyond any computer power (measured in GB). Chess for example knows
10^120 positions! The atoms needed to build the universe is 10^84!    
So we have to cut the lower part of the game tree, giving the algorithm
a certain depth as a natural. The upper part of the game tree is our 
search tree. For that search tree we need:
<OL>
<LI>  Each node of the search tree is a position.
<LI>  If they have to move, the node is an AND node.
<LI>  If we have to move, the node is an OR node.
<LI>  Each node has a static value, anyhow computed (static_value/2).
<LI>  Each node has an alternativ list of successors (moves/2).
<LI>  The position is estimated from our point of view as follows:
<OL>
<LI>  If we are to move we take the maximum (MAX) of the list of values.
<LI>  If they are to move we take the mininum (MIN) of the values.
</OL>
</OL>
Notice that given the first few moves in a search tree, the whole
game tree is determinated.
Now we have at static evaluation of each node (or position) and the
depth of the search tree is worked down. How do we know at our current
position which move do we have to make?
The answer is as simple as naive! We propagate the values from the leaves
of the computed search tree to the root the following way:
<UL>
<LI> If the upper node is an OR node we take the maximum of the values.
<LI> If the upper node is an AND node we take the minimum of the values.
</UL>
Summarizing all these facts we have the complete information to implement
the min_max/3 algorithm. One thing that has not been mentioned yet, 
is the move to be played. As we are concerned only by the evaluation 
of the position the move plays a secondary role. We discuss it later. */

/** Alpha_Beta: Efficient implementation of the minimax principle */

/** Looking correctly at the code for min_max/3 you see that min_max/3
visits all possible moves from the root to the leaves of the search tree.
In fact that is far too much work for computing the min_max/3 value 
of the root position. Follow this argumentation.
Suppose we have an OR node (the move with a maximum value is searched,  
n = 3 = search depth). In this position we have exactly two alternative 
moves m1 and m2. We can show that m1 is clearly inferior to m2. 
The exact difference does not bother us. The less relation is sufficient
to make the right decision. We reach to following proccess:
<OL>
<LI> n = 3: We have a position p, and p is an OR node.
<LI> Calculate the two possible moves m1 and m2.
<LI> n = 2: We have two positions p1 and p2, which are AND nodes.
<LI> Calculate moves m1(p1) and m2(p1).
<LI> n = 1: The positions p1(p1) and p2(p1) are OR nodes.
<LI> n = 0: Calculate positions k1 to kn from postion p1(p1).
<LI> Take maximum vi from values v1 to vn depending from k1 to kn.
<LI> If static value of p1(p1) < v = vi else v = static value of p1(p1).
<LI> p1(p1) and p2(p1) are OR nodes. Maximum is searched. 
     Assume the static value v(p2(p1)) is greater v.
<LI> As p1 is an AND node the minimum is v, so we do not have to 
     compute the branch of p2(p1).
</OL>
Even we do not know the exact value of p2(p1) we know that it is superior
to v because at that node we need the maximum of the successors. So we
can approximate the value of p2(p1) by the static value of p2(p1).
Notice that the cut of that branch has no effect of the value propagated
bottom-up to the root. The list of positions need to be computed is reduced.
With this idea we can introduce two bounds, Alpha and Beta, which have 
following meaning:
<UL>
<LI> If x is an OR node, Alpha is the granted minimal value of x and
     Beta is the maximal value x can achieve.
<LI> If x is an AND node, Alpha is the maximal value x can achieve and
     Beta is the granted minimal value of x.
</UL>
So we only have to know the exact value of x if Alpha < V(x) < Beta.
Arguing that way, Alpha_Beta prunning has following properties:
<OL>
<LI> Each node of the search tree is a position.
<LI> If they have to move, the node is an AND node.
<LI> If we have to move, the node is an OR node.
<LI> Each node has a static value, anyhow computed (static_value/2).
<LI> Each node has an alternativ list of successors (moves/2).
<LI> The position is estimated from our point of view as follows:
<OL>
<LI> If we have to move:
<OL>
<LI> Alpha < V(x) < Beta, if Beta =< Alpha or the list of moves is empty.
<LI> Calculate for the first possible postion p1 alpha_beta/5; take
     V = maximum of Alpha and V(p1); exchange Alpha and V; repeat
     recursively the procedure with the new bounds with the rest of 
     successors of x. 
</OL>
<LI> If they have to move:
<OL>
<LI> Alpha < V(x) < Beta, if Beta =< Alpha or the list of moves is empty.
<LI> Calculate for the first possible postion p1 alpha_beta/5; take
     V = minimum of Beta and V(p1); exchange Beta and V; repeat 
     recursivly the procedure with the new bounds with the rest of 
     successors of x.
</OL>  
</OL>
</OL>
Now we have a bounded or efficient implementation of the minimax
principle which we can one to one translate into PROLOG. */

/** Proof of equivalence */
 
/** To do the equivalence proof we work with a util called LPTP:
Logic Program Theorem Prover. It is an interactive theorem prover 
for the formal verification of Prolog programs. The functionality
of this util can be visited at /home/staerk/lptp/doc/user.dvi. Here we are
going to mention only a few points concerning that util.
<OL>
<LI> To write the Prolog code we needed to relations =< and <.
     For =< we had to define a partial ordring #=< to conclude on the
     properties of #<. Some of those conclusions are superficial, but show
     how easy you can split complex proofs, what we didn't later.
     The partial ordering we introduced was based on the type val/1(value).
<LI> As we assumed  that the static_value/2, moves/2 and pos/2 calculated 
     in the specific game are guaranteed, we had to define generic axioms for:
<OL>
<LI> <TT>pos/2</TT>: specification of the type position
<LI> <TT>moves/2</TT>: what are the properties of the moves
<LI> <TT>static_value/2</TT>: properties of the static value of a position
</OL>
</OL>
As you can easily see, there was always the same idea behind the
axiomatic. First we assumed, that the used functions terminate, i.e. do
not produce an endlessloop. Second we made clear what return type
they had. Third we assured the expected return value existed. 
Fourth the uniqueness of the return value.
After these statements we could define function symbols and prove
some properties of these function symbols.
The same way we procceed in the proof itself.
To prove equivalence for min_max/3 and alpha_beta/5 it is neccessary
to find an isomorphism between the values of min_max/3 and alpha_beta/5.
It is very simple to do so, if you cut the values outside the bounds.
So if we have the discret value M(x) of a position x returned by 
min_max/3 and we would like to set it in relation to the value A(x)
returned by alpha_beta/5.
Looking to the properties (6) a and b in the specification of
alha_beta/5 we can easely conlude, that:
<UL>
<LI> If M(x) =< Alpha then V(x) =< Alpha
<LI> If Alpha < M(x) < Beta then M(x) = V(x)
<LI> If Beta =< M(x) then Beta =< V(x)
<LI> If Alpha = +infinity and Beta = -infinity then M(x) = V(x) for all x
</UL>
The first three statements we prove by induction on the depth of the
search tree and induction on the length of the position list. */
 
/** Summary */

/** Now as we have proven equivalence of min_max/3 and alpha_beta/5, at
least equivalence of the returned values, we have to pose the following 
question: Is the corresponding move returned by min_max/3 
and alpha_beta/5 the same?
To prove that proposition, we have to assume that the generated position 
list for <TT>min_max/3</TT> and <TT>alpha_beta/5</TT> is the same and in 
the same order. So if two positions have the same value, min_max/3 shall 
take the first. alpha_beta/5 does it automatically, which you can 
immediately conclude from the process designed for. So the proof is 
complete. */ 

/** Properties of <TT>#<</TT> what means <TT><</TT>.
It is clear that with the <TT>axiom(value:leq:total)</TT> you can
prove any lemma needed for proving the equivalence of 
<TT>alpha_beta</TT> and <TT>min_max</TT>. Nevertheless the entire
proof gets much clearer and modular splitting it in pieces, instead of
always repeat them in one or another way during the proof. So if you do
not see with the first sight why making such a "circus" for these
trivialities and the remarks for the proof do not explain
the importance of the following lemmas try to prove e.g. 
<TT>lemma(min:types)</TT> or then <TT>lemma(min_max:types)</TT>
without the properties of <TT>#<</TT>, what describes <TT><</TT>. 
One important feature is the way those properties are proved. 
It is always a case splitting using the <TT>axiom(value:leq:total)</TT>.*/

/** To be sure that the question: Is <TT>v < w</TT> does not produce
an endlessloop, knowing that v and w are values, not specified in
detail. The program has to give a clear response <TT>yes</TT> or
<TT>no</TT>. Simpler question is to ask if <TT>v < w</TT> terminates. */

:- lemma(value:less:termination,
all [v,w]: succeeds val(?v) & succeeds val(?w) => 
  terminates ?v #< ?w,
assume(succeeds val(?v) & succeeds val(?w),
 [terminates ?v #=< ?w by axiom(value:leq:termination),
  assume(succeeds ?v #=< ?w,
   [gr(?v) by axiom(value:ground),
    gr(?w) by axiom(value:ground)],
   gr(?v) & gr(?w)),
  terminates (?v #=< ?w & ~ ?v = ?w),
  terminates ?v #< ?w by completion],
 terminates ?v #< ?w)
).

/** If you have equality between two values v and w, it is evident
that both relations <TT>v =< w</TT> and <TT>w =< v</TT> are
satisfied. Making sure this evidence for the system <TT>LPTP</TT>
the following lemma has to be proved. Notice that a simple case splitting 
gets the way. */

:- lemma(value:less:eq,
all [v,w]:succeeds val(?v) & succeeds val(?w) & ?v = ?w =>
   succeeds ?v #=< ?w & succeeds ?w #=< ?v,
assume(succeeds val(?v) & succeeds val(?w) & ?v = ?w,
 [succeeds ?v #=< ?w \/ succeeds ?w #=< ?v by axiom(value:leq:total),
  cases(succeeds ?v #=< ?w,[],succeeds ?w #=< ?v,[],succeeds ?v #=< ?w),
  succeeds ?w #=< ?v],
 succeeds ?v #=< ?w & succeeds ?w #=< ?v)
).

/** This lemma is only the <TT>negation</TT> of the <TT>lemma(value:total)</TT>.
It works the same way: case splitting. */

:- lemma(value:less:few,
all [v,w]: succeeds val(?v) & succeeds val(?w) & fails ?v #=< ?w =>
   succeeds ?w #=< ?v,
assume(succeeds val(?v) & succeeds val(?w) & fails ?v #=< ?w,
 [succeeds val(?v) & succeeds val(?w),
  succeeds ?v #=< ?w \/ succeeds ?w #=< ?v by axiom(value:leq:total),
  cases(succeeds ?v #=< ?w,[],succeeds ?w #=< ?v,[],succeeds ?w #=< ?v)],
 succeeds ?w #=< ?v)
).

/** Having the relation <TT>v =< w</TT> for two values v and w, it
is useful two have another interpretion of that result, which is proved
below. */

:- lemma(value:less:com,
all [v,w]: succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w =>
   fails ?w #=< ?v \/ ?v = ?w,
assume(succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w,
 [succeeds ?v #=< ?w \/ ?v = ?w \/ succeeds ?w #=< ?v,
  cases(
   [case(succeeds ?v #=< ?w,
	  [terminates ?v #< ?v by lemma(value:less:termination),
           terminates ?w #=< ?v by axiom(value:leq:termination),
           cases(succeeds ?w #=< ?v,
            ?v = ?w by axiom(value:leq:antisymmetric),
            fails ?w #=< ?v,
            [],
            fails ?w #=< ?v \/ ?v = ?w)]),
    case(?v = ?w,
     []),
    case(succeeds ?w #=< ?v,
     [succeeds ?v #=< ?w & succeeds ?w #=< ?v,
      ?v = ?w by axiom(value:leq:antisymmetric),
      fails ?w #=< ?v \/ ?v = ?w])],
   fails ?w #=< ?v \/ ?v = ?w)],
 fails ?w #=< ?v \/ ?v = ?w)
).

/** Knowing one detail more than in the preceeding lemma, one relation
can be excluded.
Detail: The two values are not equal! */

:- lemma(value:less:ref,
all [v,w]: succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w &
  ?v <> ?w => fails ?w #=< ?v,
assume(succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w & ?v <> ?w,
 [succeeds val(?v) & succeeds val(?w),
  succeeds ?v #=< ?w \/ ?v = ?w \/ succeeds ?w #=< ?v,
  cases(
   [case(succeeds ?v #=< ?w,
         [succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w,
          fails ?w #=< ?v \/ ?v = ?w by lemma(value:less:com),
          cases(fails ?w #=< ?v,[],?v = ?w,[],fails ?w #=< ?v)]),
    case(?v = ?w,
     []),
    case(succeeds ?w #=< ?v,
     [succeeds ?w #=< ?v & succeeds ?v #=< ?w,
      ?v = ?w by axiom(value:leq:antisymmetric),
      ?v <> ?w & ?v = ?w,
      fails ?w #=< ?v])],
   fails ?w #=< ?v)],
 fails ?w #=< ?v)
).

/** The following lemma is only another interpretation of 
<TT>lemma(value:less:ref)</TT>, but in some steps of the proof  very 
useful. */

:- lemma(value:less:ineq,
all [v,w]:succeeds val(?v) & succeeds val(?w) & fails ?v #=< ?w &
   succeeds ?w #=< ?v => ?v <> ?w,
assume(succeeds val(?v) & succeeds val(?w) & fails ?v #=< ?w &
 succeeds ?w #=< ?v,
 [succeeds ?v #=< ?w \/ ?v = ?w \/ succeeds ?w #=< ?v,
  cases(
   [case(succeeds ?v #=< ?w,[]),
    case(?v = ?w,
     [succeeds ?v #=< ?w & succeeds ?w #=< ?v,
      ?v <> ?w]),
    case(succeeds ?w #=< ?v,
     [fails ?v #=< ?w \/ ?v = ?w,
      cases(fails ?v #=< ?w,
       [contra(?v = ?w,
         [succeeds ?v #=< ?w & succeeds ?w #=< ?v,
          fails ?v #=< ?w & succeeds ?v #=< ?w,
	  ff]),
	?v <> ?w],
       ?v = ?w,
       [succeeds ?v #=< ?w & succeeds ?w #=< ?v,
	?v <> ?w],
       ?v <> ?w)])],
   ?v <> ?w)],
 ?v <> ?w)
).

/** Looking at the prolog code for <TT>min_max/3 & alpha_beta/5</TT> you 
recognize that not only the <TT>=<</TT> relation but also the
<TT><</TT> relation appears. So consequently one has to prove the
properties for the second relation between two values. */  

:- lemma(value:less:total,
all [v,w]: succeeds val(?v) & succeeds val(?w) =>
  succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v,
assume(succeeds val(?v) & succeeds val(?w),
 [terminates ?v #< ?w by lemma(value:less:termination),
  succeeds ?v #< ?w \/ fails ?v #< ?w,
  terminates ?w #< ?v by lemma(value:less:termination),
  succeeds ?w #< ?v \/ fails ?w #< ?v,
  terminates ?v #< ?w \/ terminates ?w #< ?v,
  succeeds ?v #< ?w \/ fails ?v #< ?w \/ succeeds ?w #< ?v \/ 
  fails ?w #< ?v,
  succeeds ?v #=< ?w \/ succeeds ?w #=< ?v by axiom(value:leq:total),
  succeeds ?v #< ?w \/ fails ?v #< ?w \/ succeeds ?w #< ?v \/ 
  fails ?w #< ?v \/ succeeds ?v #=< ?w \/ succeeds ?w #=< ?v, 
  cases(succeeds ?v #< ?w,
   [],
   fails ?v #< ?w,
   [def fails ?v #< ?w by completion,
    cases(fails ?v #=< ?w,
     [succeeds ?w #=< ?v by lemma(value:less:few),
      succeeds val(?v) & succeeds val(?w) & succeeds ?w #=< ?v,
     fails ?v #< ?w & succeeds ?w #=< ?v,
     succeeds val(?v) & succeeds val(?w) & fails ?v #=< ?w &
     succeeds ?w #=< ?v,
     ?v <> ?w by lemma(value:less:ineq),
     succeeds ?w #=< ?v & ?w <> ?v,
     succeeds ?w #< ?v by completion,
     succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v],
     ?v = ?w,
     [],
     succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v)],
   succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v),
   succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v],
 succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v)
).

/** If you know that the relation <TT>v < w</TT> succeeds, it is
clear that the other <TT>w < v</TT> fails, having the strictly 
mathematical interpretation of the two relations in mind. */  

:- lemma(value:less:intr,
all [v,w]: succeeds val(?v) & succeeds val(?w) &  succeeds ?v #< ?w =>
 fails ?w #< ?v,
assume(succeeds val(?v) & succeeds val(?w) & succeeds ?v #< ?w,
 [succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v,
  def succeeds ?v #< ?w by completion,
  fails ?w #< ?v & ?v <> ?w by lemma(value:less:ref),
  fails ?w #< ?v],
 fails ?w #< ?v)
).

/** One important property of the less relation is the transitivity.
This property is getting important at the end of this proof. */

:- lemma(value:less:transitive,
all [u,v,w]: succeeds val(?u) & succeeds val(?v) & succeeds val(?w) &
 succeeds ?u #< ?v & succeeds ?v #< ?w => succeeds ?u #< ?w,
assume(succeeds val(?u) & succeeds val(?v) & succeeds val(?w) &
 succeeds ?u #< ?v & succeeds ?v #< ?w,
 [succeeds ?u #< ?w \/ ?u = ?w \/ succeeds ?w #< ?u by 
   lemma(value:less:total),
  cases(
   [case(succeeds ?u #< ?w,[]),
    case(?u = ?w,
     [fails ?u #< ?w & fails ?w #< ?u,
      succeeds ?u #< ?v & succeeds ?v #< ?w & ?u = ?w,
      succeeds ?u #< ?v & succeeds ?v #< ?u,
      succeeds ?u #< ?v,
      fails ?v #< ?u by lemma(value:less:intr),
      succeeds ?w #< ?v & succeeds ?v #< ?w,
      succeeds ?u #< ?w]),
    case(succeeds ?w #< ?u,
     [succeeds ?u #< ?v & succeeds ?v #< ?w & succeeds ?w #< ?u,
      def succeeds ?u #< ?v by completion,
      fails ?v #< ?u by lemma(value:less:intr),
      fails ?v #< ?u & ?u <> ?v,
      def succeeds ?v #< ?w by completion,
      fails ?w #< ?v by lemma(value:less:intr),
      fails ?w #< ?v & ?v <> ?w,
      def succeeds ?w #< ?u by completion,
      fails ?u #< ?w by lemma(value:less:intr),
      fails ?u #< ?w & ?w <> ?u,
      succeeds ?u #< ?w by axiom(value:leq:transitive)])],
   succeeds ?u #< ?w)],
 succeeds ?u #< ?w)
).

/** This lemma says only that a value cannot have another relation to
itself, except the equality relation. */

:- lemma(value:less:irreflexive,
all v: succeeds val(?v) => fails ?v #< ?v,
succeeds val(?v) => fails ?v #< ?v
).

/** Until now we have only proven the properties for the two
relations seperately. But it is necessary to make in evidence
the ralations between <TT>=<</TT> and <TT><</TT>. At least
the system should know that if <TT>v =< w</TT>, then
<TT>v < w</TT> or <TT>v = w</TT>. */

:- lemma(value:weak,
all [v,w]: succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w =>
 succeeds ?v #< ?w \/ ?v = ?w,
assume(succeeds val(?v) & succeeds val(?w) & succeeds ?v #=< ?w,
 [succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v by 
   lemma(value:less:total), 
  cases(
   [case(succeeds ?v #< ?w,[]),
    case(?v = ?w,
     []),
    case(succeeds ?w #< ?v,
     [succeeds ?v #=< ?w \/ succeeds ?w #=< ?v,
      cases(succeeds ?v #=< ?w,
       [succeeds ?w #< ?v,
	def succeeds ?w #< ?v by completion,succeeds ?v #< ?w \/ ?v = ?w],
       succeeds ?w #=< ?v,
       [succeeds ?w #< ?v,
	def succeeds ?w #< ?v by completion,succeeds ?v #< ?w \/ ?v = ?w],
       succeeds ?v #< ?w \/ ?v = ?w)])],
   succeeds ?v #< ?w \/ ?v = ?w)],
 succeeds ?v #< ?w \/ ?v = ?w)
).

/** Not having to make case splitting at the end of this proof one 
other relation between <TT><</TT> and <TT>=<</TT> makes life much easier.
For two values v and w you can always distinguish:
<OL>
<LI> <TT>v < w</TT> or
<LI> <TT>w =< v</TT> 
</OL> */ 

:- lemma(value:lessleq,
all [v,w]: succeeds val(?v) & succeeds val(?w) =>
 succeeds ?v #< ?w \/ succeeds ?w #=< ?v,
assume(succeeds val(?v) & succeeds val(?w),
 [succeeds ?v #=< ?w \/ succeeds ?w #=< ?v by axiom(value:leq:total),
  cases(succeeds ?v #=< ?w,
   [succeeds ?v #< ?w \/ ?v = ?w by lemma(value:weak),
    cases(succeeds ?v #< ?w,
     [],
     ?v = ?w,
     [],
     succeeds ?v #< ?w \/ succeeds ?w #=< ?v)],
   succeeds ?w #=< ?v,
   [],
   succeeds ?v #< ?w \/ succeeds ?w #=< ?v)],
 succeeds ?v #< ?w \/ succeeds ?w #=< ?v)
).

/** Another interpretation of the preceeding lemma. */

:- lemma(value:leqless,
all [v,w]: succeeds val(?v) & succeeds val(?w) &
 succeeds ?v #< ?w => fails ?w #=< ?v,
assume(succeeds val(?v) & succeeds val(?w) & succeeds ?v #< ?w,
 [succeeds ?v #< ?w \/ ?v = ?w \/ succeeds ?w #< ?v,
  succeeds ?v #< ?w,
  def succeeds ?v #< ?w by completion,
  contra(?v = ?w & succeeds ?w #< ?v,
   []),
  fails ?w #=< ?v by lemma(value:less:ref)],
 fails ?w #=< ?v)
). 

/** Properties of <TT>max/3</TT>. */

/** Looking at the prolog code you'll see that there is a rule which
gets two parameters and returns the maximum of both. So it essentially
to know if this rule is well defined. So we have to be sure that for
any input the rule <TT>max(v1,v2,v)</TT> terminates. That assures 
the next lemma. */

:- lemma(max:termination,
all [u,v,w]: succeeds val(?u) & succeeds val(?v) => terminates max(?u,?v,?w),
assume(succeeds val(?u) & succeeds val(?v),
 [terminates ?u #=< ?v by axiom(value:leq:termination), 
  terminates ?v #=< ?u by axiom(value:leq:termination),
  terminates max(?u,?v,?w) by axiom(value:ground)],
 terminates max(?u,?v,?w))
).

/** Knowing that the rule <TT>max/3</TT> terminates does not imply the 
existence of the maximum for two inputs. That proves the next lemma. 
Notice: At this point it is not sufficient to make the case splitting.
        Here you need the first time a existence quantifier. Another 
        aspect ist the way you prove existence. For that you need the
        assurance that the existence follows implicitly from the rule. */

:- lemma(max:existence,
all [u,v]: succeeds val(?u) & succeeds val(?v) =>
 (ex w: succeeds max(?u,?v,?w)),
assume(succeeds val(?u) & succeeds val(?v),
 [terminates ?u #=< ?v by axiom(value:leq:termination),
  succeeds ?u #=< ?v \/ fails ?u #=< ?v,
  cases(succeeds ?u #=< ?v,
   [succeeds max(?u,?v,?v),
    ex w: succeeds max(?u,?v,?w)],
   fails ?u #=< ?v,
   [succeeds max(?u,?v,?u),
    ex w: succeeds max(?u,?v,?w)],
   ex w: succeeds max(?u,?v,?w))],
 ex w: succeeds max(?u,?v,?w))
).

/** Until now we are sure that the rule <TT>max/3</TT> terminates and
the return value exists. But like in mathemathics the uniqueness of
a sulotion of an algorithm should be granted. What leads to
the following lemma. */

:- lemma(max:uniqueness,
all [u,v,w1,w2]: succeeds val(?u) & succeeds val(?v) &
 succeeds max(?u,?v,?w1) & succeeds max(?u,?v,?w2) => ?w1 = ?w2,
assume(succeeds val(?u) & succeeds val(?v) & succeeds max(?u,?v,?w1) &
 succeeds max(?u,?v,?w2),
 [def succeeds max(?u,?v,?w1) by completion,
  cases(succeeds ?u #=< ?v & ?w1 = ?v,
   [succeeds max(?u,?v,?w2),
    def succeeds max(?u,?v,?w2) by completion,
    cases(succeeds ?u #=< ?v & ?w2 = ?v,
     [],
     fails ?u #=< ?v & ?w2 = ?u,
     [],
     ?w1 = ?w2)],
   fails ?u #=< ?v & ?w1 = ?u,
   [succeeds max(?u,?v,?w2),
    def succeeds max(?u,?v,?w2) by completion,
    cases(succeeds ?u #=< ?v & ?w2 = ?v,
     [],
     fails ?u #=< ?v & ?w2 = ?u,
     [],
     ?w1 = ?w2)],
   ?w1 = ?w2)],
 ?w1 = ?w2)
).

/** We can define a function <TT>maxf</TT>. */

/** The definition of function symbols simplifies life extremly. When and 
how it is possible to define functions is decribed in 
<TT>/home/staerk/lptp/doc/user.dvi</TT>. */ 

:- definition_fun(maxf,2,
all [u,v,w]: succeeds val(?u) & succeeds val(?v) =>
 (maxf(?u,?v) = ?w <=> succeeds max(?u,?v,?w)),
existence by lemma(max:existence),
uniqueness by lemma(max:uniqueness)
).

/** In the prolog code we have defined exactly the return value of
the rule <TT>max/3</TT>. Under certain conditions we could for LPTP
define a function <TT>maxf/2</TT>. For this function we have to
prove certain properties. One is that if the type of the input-variables
u and v is value and u =< v, then the maxf(u,v) = v. */   

:- lemma(maxf:leq:1,
all [u,v]: succeeds val(?u) & succeeds val(?v) & succeeds ?u #=< ?v =>
  maxf(?u,?v) = ?v,
assume(succeeds val(?u) & succeeds val(?v) & succeeds ?u #=< ?v,
 maxf(?u,?v) = ?v by uniqueness(maxf,2),
 maxf(?u,?v) = ?v)
).

/** Otherwise the maxf(u,v) = u. Here the importance of the 
relation properties. */     

:- lemma(maxf:leq:2,
all [u,v]: succeeds val(?u) & succeeds val(?v) & succeeds ?v #=< ?u =>
  maxf(?u,?v) = ?u,
assume(succeeds val(?u) & succeeds val(?v) & succeeds ?v #=< ?u,
 [?u = ?u,
  succeeds ?v #=< ?u,
  succeeds ?v #=< ?u \/ succeeds ?u #=< ?v,
  cases(succeeds ?v #=< ?u,
   [succeeds val(?u) & succeeds val(?v) & succeeds ?v #=< ?u,
    fails ?u #=< ?v \/ ?v = ?u by lemma(value:less:com),
    cases(fails ?u #=< ?v,
     [],
     ?v = ?u,
     [],
     succeeds ?u #=< ?v & ?u = ?v \/ fails ?u #=< ?v & ?u = ?u)],
   succeeds ?u #=< ?v,
   [succeeds ?u #=< ?v & succeeds ?v #=< ?u,
    ?u = ?v by axiom(value:leq:antisymmetric),
    succeeds ?u #=< ?v & ?u = ?v \/ fails ?u #=< ?v & ?u = ?u],
   succeeds ?u #=< ?v & ?u = ?v \/ fails ?u #=< ?v & ?u = ?u),
  succeeds max(?u,?v,?u) by completion,
  maxf(?u,?v) = ?u by uniqueness(maxf,2)],
 maxf(?u,?v) = ?u)
).

/** Properties of <TT>min/3</TT>. */

/** Like for the rule <TT>max/3</TT> also for the rule <TT>min/3</TT>, which
returns the minimum of two values we have to prove:
First: the termination of min. */

:- lemma(min:termination,
all [u,v,w]: succeeds val(?u) & succeeds val(?v) => terminates min(?u,?v,?w),
assume(succeeds val(?u) & succeeds val(?v),
 [terminates ?u #=< ?v by axiom(value:leq:termination),
  terminates ?v #=< ?u by axiom(value:leq:termination),
  terminates min(?u,?v,?w) by axiom(value:ground)],
 terminates min(?u,?v,?w))
).

/** Second: the existence of min. */

:- lemma(min:existence,
all [u,v]: succeeds val(?u) & succeeds val(?v) =>
 (ex w: succeeds min(?u,?v,?w)),
assume(succeeds val(?u) & succeeds val(?v),
 [terminates ?u #=< ?v by axiom(value:leq:termination),
  succeeds ?u #=< ?v \/ fails ?u #=< ?v,
  cases(succeeds ?u #=< ?v,
   [succeeds min(?u,?v,?u),
    ex w: succeeds min(?u,?v,?w)],
   fails ?u #=< ?v,
   [succeeds min(?u,?v,?v),
    ex w: succeeds min(?u,?v,?w)],
   ex w: succeeds min(?u,?v,?w))],
 ex w: succeeds min(?u,?v,?w))
).

/** Third: the uniqueness of min. */

:- lemma(min:uniqueness,
all [u,v,w1,w2]: succeeds val(?u) & succeeds val(?v) &
 succeeds min(?u,?v,?w1) & succeeds min(?u,?v,?w2) => ?w1 = ?w2,
assume(succeeds val(?u) & succeeds val(?v) & succeeds min(?u,?v,?w1) &
 succeeds min(?u,?v,?w2),
 [def succeeds min(?u,?v,?w1) by completion,
  cases(succeeds ?u #=< ?v & ?w1 = ?u,
   [succeeds min(?u,?v,?w2),
    def succeeds min(?u,?v,?w2) by completion,
    cases(succeeds ?u #=< ?v & ?w2 = ?u,
     [],
     fails ?u #=< ?v & ?w2 = ?v,
     [],
     ?w1 = ?w2)],
   fails ?u #=< ?v & ?w1 = ?v,
   [succeeds min(?u,?v,?w2),
    def succeeds min(?u,?v,?w2) by completion,
    cases(succeeds ?u #=< ?v & ?w2 = ?u,
     [],
     fails ?u #=< ?v & ?w2 = ?v,
     [],
     ?w1 = ?w2)],
   ?w1 = ?w2)],
 ?w1 = ?w2)
).

/** We can define a function <TT>minf</TT>. */

/** Exactly like for max we define for min a function symbol. */

:- definition_fun(minf,2,
all [u,v,w]: succeeds val(?u) & succeeds val(?v) =>
 (minf(?u,?v) = ?w <=> succeeds min(?u,?v,?w)),
existence by lemma(min:existence),
uniqueness by lemma(min:uniqueness)
).

/** The function defined for min has also two properties.
First: if u =< v then minf(u,v) = u. */

:- lemma(minf:leq:1,
all [u,v]: succeeds val(?u) & succeeds val(?v) & succeeds ?u #=< ?v =>
  minf(?u,?v) = ?u,
assume(succeeds val(?u) & succeeds val(?v) & succeeds ?u #=< ?v,
 [succeeds ?u #=< ?v \/ succeeds ?v #=< ?u,
  cases(succeeds ?u #=< ?v,
   minf(?u,?v) = ?u by uniqueness(minf,2),
   succeeds ?v #=< ?u,
   minf(?u,?v) = ?u by uniqueness(minf,2),
   minf(?u,?v) = ?u)],
 minf(?u,?v) = ?u)
).

/** Second: if v =< u then minf(u,v) = v. */

:- lemma(minf:leq:2,
all [u,v]: succeeds val(?u) & succeeds val(?v) & succeeds ?v #=< ?u =>
  minf(?u,?v) = ?v,
assume(succeeds val(?u) & succeeds val(?v) & succeeds ?v #=< ?u,
 [succeeds ?u #=< ?v \/ succeeds ?v #=< ?u,
  cases(succeeds ?u #=< ?v,
   [fails ?v #=< ?u \/ ?u = ?v by lemma(value:less:com),
    cases(fails ?v #=< ?u,
     [],
     ?u = ?v,
     [],
     succeeds ?u #=< ?v & ?v = ?u \/ fails ?u #=< ?v & ?v = ?v),
    succeeds min(?u,?v,?v) by completion,
    minf(?u,?v) = ?v by uniqueness(minf,2)],
   succeeds ?v #=< ?u,
   [fails ?u #=< ?v \/ ?v = ?u by lemma(value:less:com),
    cases(fails ?u #=< ?v,
     [],
     ?v = ?u,
     [],
     succeeds ?u #=< ?v & ?v = ?u \/ fails ?u #=< ?v & ?v = ?v),
    succeeds min(?u,?v,?v) by completion,
    minf(?u,?v) = ?v by uniqueness(minf,2)],
   minf(?u,?v) = ?v)],
 minf(?u,?v) = ?v)
).

/** Properties of <TT>min_max/3</TT>, <TT>min_list/3</TT>,
<TT>max_list/3</TT>. */

/** Remember that the <TT>min_max/3</TT> algorithm evaluates a position in a
game tree. For that it is important that the type of the calculus is
of type value. Same property has to be proven for <TT>min_list/3</TT> and
<TT>max_list/3</TT>. As min_max/3 depends recursivly on <TT>min_list/3</TT> 
<TT>max_list/3</TT> it is inevitable to prove the type property for all
three rules simultanously. Induction on the length of parameters 
is the best way to do it.*/

:- lemma(min_max:types,
(all [p,n,v]: succeeds min_max(?p,?n,?v) =>
  (succeeds pos(?p) => succeeds val(?v))) &
(all [l,n,v]: succeeds min_list(?l,?n,?v) =>
   (succeeds pos_list(?l) => succeeds val(?v))) &
(all [l,n,v]: succeeds max_list(?l,?n,?v) =>
   (succeeds pos_list(?l) => succeeds val(?v))),
induction(
 [all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
     succeeds val(?v),
  all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
     succeeds val(?v),
  all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
     succeeds val(?v)],
 [step([p,v],
   [succeeds static_value(?p,?v)],
   assume(succeeds pos(?p),
    succeeds val(?v) by axiom(static_value:types),
    succeeds val(?v)),
   succeeds pos(?p) => succeeds val(?v)),
  step([p,n,v,l],
   [succeeds pos_list(?l) => succeeds val(?v),
    succeeds and_pos(?p),
    succeeds moves(?p,?l),
    succeeds min_list(?l,?n,?v)],
   assume(succeeds pos(?p),
    succeeds val(?v) by axiom(moves:list:types),
    succeeds val(?v)),
   succeeds pos(?p) => succeeds val(?v)),
  step([p,n,v,l],
   [succeeds pos_list(?l) => succeeds val(?v),
    succeeds or_pos(?p),
    succeeds moves(?p,?l),
    succeeds max_list(?l,?n,?v)],
   assume(succeeds pos(?p),
    succeeds val(?v) by axiom(moves:list:types),
    succeeds val(?v)),
   succeeds pos(?p) => succeeds val(?v)),
  step([0],
   [],
   assume(succeeds pos_list([]),
    succeeds val(top) by axiom(value:top),
    succeeds val(top)),
   succeeds pos_list([]) => succeeds val(top)),
  step([x,l,n,v,v1,v2],
   [succeeds pos(?x) => succeeds val(?v1),
    succeeds pos_list(?l) => succeeds val(?v2),
    succeeds min_max(?x,?n,?v1),
    succeeds min_list(?l,?n,?v2),
    succeeds min(?v1,?v2,?v)],
   assume(succeeds pos_list([?x|?l]),
    [def succeeds pos_list([?x|?l]) by completion,succeeds pos(?x),
     succeeds val(?v1),
     succeeds pos_list(?l),
     succeeds val(?v2),
     succeeds min(?v1,?v2,?v),
     def succeeds min(?v1,?v2,?v) by completion,
     cases(succeeds ?v1 #=< ?v2 & ?v = ?v1,
      [],
      fails ?v1 #=< ?v2 & ?v = ?v2,
      [],
      succeeds val(?v))],
    succeeds val(?v)),
   succeeds pos_list([?x|?l]) => succeeds val(?v)),
  step([0],
   [],
   assume(succeeds pos_list([]),
    succeeds val(bot) by axiom(value:bot),
    succeeds val(bot)),
   succeeds pos_list([]) => succeeds val(bot)),
  step([x,l,n,v,v1,v2],
   [succeeds pos(?x) => succeeds val(?v1),
    succeeds pos_list(?l) => succeeds val(?v2),
    succeeds min_max(?x,?n,?v1),
    succeeds max_list(?l,?n,?v2),
    succeeds max(?v1,?v2,?v)],
   assume(succeeds pos_list([?x|?l]),
    [def succeeds pos_list([?x|?l]) by completion,succeeds pos(?x),
     succeeds val(?v1),
     succeeds pos_list(?l),
     succeeds val(?v2),
     succeeds max(?v1,?v2,?v),
     def succeeds max(?v1,?v2,?v) by completion,
     cases(succeeds ?v1 #=< ?v2 & ?v = ?v2,
      [],
      fails ?v1 #=< ?v2 & ?v = ?v1,
      [],
      succeeds val(?v))],
    succeeds val(?v)),
   succeeds pos_list([?x|?l]) => succeeds val(?v))])
).

/** Sometimes it is important to know only the type of <TT>min_max/3</TT>, not
being concerned with the type of <TT>min_list/3</TT> or <TT>max_list/3</TT>.*/

:- corollary(min_max:types,
all [p,n,v]: succeeds pos(?p) &  succeeds min_max(?p,?n,?v) => 
 succeeds val(?v),
assume(succeeds pos(?p) & succeeds min_max(?p,?n,?v),
 [all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
     succeeds val(?v) by lemma(min_max:types),
  succeeds pos(?p) => succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** In steps of the proof of <TT>theorem(main)</TT> it is important
to know the return type of <TT>min_list/3</TT> without assuming anything for
the return type of <TT>min_max/3</TT>, namely value. */

:- corollary(min_list:types,
all [l,n,v]: succeeds pos_list(?l) & succeeds min_list(?l,?n,?v) =>
  succeeds val(?v),
assume(succeeds pos_list(?l) & succeeds min_list(?l,?n,?v),
 [all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
     succeeds val(?v) by lemma(min_max:types), 
  succeeds pos_list(?l) => succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** In steps of the proof of <TT>theorem(main)</TT> it is important
to know the return type of <TT>max_list/3</TT> without assuming anything for
the return type of <TT>min_max/3</TT>, namely value. */

:- corollary(max_list:types,
all [l,n,v]: succeeds pos_list(?l) & succeeds max_list(?l,?n,?v) =>
  succeeds val(?v),
assume(succeeds pos_list(?l) & succeeds max_list(?l,?n,?v),
 [all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
     succeeds val(?v) by lemma(min_max:types),
  succeeds pos_list(?l) => succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** Termination of <TT>min_max/3</TT>, <TT>min_list/3</TT>,
<TT>max_list/3</TT>. */

/** For any natural n, which significance is the depth of the game tree,
and two "different" exigences for <TT>min_max/3</TT> and
<TT>min_list/3</TT> respectively <TT>max_list/3</TT> the algorithm
terminates.
For <TT>min_max/3</TT> it should be clear that you call it from
a position. For <TT>min_list/3</TT> respectively <TT>max_list/3</TT>
a list of positions which contain moves can only call those rules.
Important for the understanding of the proof is the fact that there
are two levels of induction.
First level: induction over the natural n.
Second level: induction over the length of the list of position. */ 

/** For all integers n and for all positions p and any v <TT>min_max/3</TT>
terminates and for all position lists l and any v <TT>min_list/3</TT> and
<TT>max_list/3</TT> terminates. First level of induction goes over n [I(n)].*/ 

:- lemma(min_max:termination,
all n: succeeds nat(?n) =>
 (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
  (all [l,v]: succeeds pos_list(?l) =>
     terminates min_list(?l,?n,?v) & terminates max_list(?l,?n,?v)),
induction(
 [all n: succeeds nat(?n) => 
    (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
    (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
       terminates max_list(?l,?n,?v))],
 /** n = 0. */
 [step([],
   [],
   [assume(succeeds pos(?p),
     terminates min_max(?p,0,?v) by axiom(static_value:termination),
     terminates min_max(?p,0,?v)),
    all [p,v]: succeeds pos(?p) => terminates min_max(?p,0,?v),
    /** Second level of induction goes over the length of the 
    position-list l [I(l)]. */
    induction(
     [all l: succeeds pos_list(?l) => 
	(all v: terminates min_list(?l,0,?v) & 
	  terminates max_list(?l,0,?v))],
     /** At the beginnig the position list is empty. Call I([]). */ 
     [step([],
       [],
       terminates min_list([],0,?v) & terminates max_list([],0,?v),
       all v: terminates min_list([],0,?v) & terminates max_list([],0,?v)),
      /** Inductionstep from I(l) to I([x|l]). */
      step([x,l],
       [all v: terminates min_list(?l,0,?v) & terminates max_list(?l,0,?v),
	succeeds pos(?x),
	succeeds pos_list(?l)],
       [all [x,v1]: succeeds pos(?x) => terminates min_max(?x,0,?v1),
        terminates min_max(?x,0,?v1),
        assume(succeeds min_max(?x,0,?v1),
	 [succeeds val(?v1) by corollary(min_max:types),
	  all v2: terminates min_list(?l,0,?v2) &
           terminates max_list(?l,0,?v2),
          terminates min_list(?l,0,?v2) & terminates max_list(?l,0,?v2),
          terminates min_list(?l,0,?v2),
	  assume(succeeds min_list(?l,0,?v2),
	   [succeeds val(?v2) by corollary(min_list:types),
	    terminates min(?v1,?v2,?v) by lemma(min:termination)],
	   terminates min(?v1,?v2,?v)),
	  terminates (min_list(?l,0,?v2) & min(?v1,?v2,?v))],
	 terminates (min_list(?l,0,?v2) & min(?v1,?v2,?v))),
	terminates 
	(min_max(?x,0,?v1) & min_list(?l,0,?v2) & min(?v1,?v2,?v)),
	all [v1,v2]: 
	 terminates 
	 (min_max(?x,0,?v1) & min_list(?l,0,?v2) & min(?v1,?v2,?v)),
	terminates min_list([?x|?l],0,?v) by completion,
	assume(succeeds min_max(?x,0,?v1),
	 [succeeds val(?v1) by corollary(min_max:types),
	  all v2: terminates min_list(?l,0,?v2) &
           terminates max_list(?l,0,?v2),
          terminates min_list(?l,0,?v2) & terminates max_list(?l,0,?v2),
          terminates max_list(?l,0,?v2),
          assume(succeeds max_list(?l,0,?v2),
           [succeeds val(?v2) by corollary(max_list:types),
	    terminates max(?v1,?v2,?v) by lemma(max:termination)],
           terminates max(?v1,?v2,?v)),
          terminates (max_list(?l,0,?v2) & max(?v1,?v2,?v))],
	 terminates (max_list(?l,0,?v2) & max(?v1,?v2,?v))),
	terminates 
	(min_max(?x,0,?v1) & max_list(?l,0,?v2) & max(?v1,?v2,?v)),
	all [v1,v2]: 
	 terminates 
	 (min_max(?x,0,?v1) & max_list(?l,0,?v2) & max(?v1,?v2,?v)),
	terminates max_list([?x|?l],0,?v) by completion,
	terminates min_list([?x|?l],0,?v) &
	terminates max_list([?x|?l],0,?v)],
       all v: terminates min_list([?x|?l],0,?v) &
	terminates max_list([?x|?l],0,?v))]),
    assume(succeeds pos_list(?l),
     [all v: terminates min_list(?l,0,?v) & terminates max_list(?l,0,?v),
      terminates min_list(?l,0,?v) & terminates max_list(?l,0,?v)],
     terminates min_list(?l,0,?v) & terminates max_list(?l,0,?v))],
   (all [p,v]: succeeds pos(?p) => terminates min_max(?p,0,?v)) &
   (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,0,?v) &
      terminates max_list(?l,0,?v))),
  /** Here begins the inductionstep for I(n) to I(n+1).
  Notice the distinction for a and-node and or-node in the game-tree. */ 
  step([x],
   [(all [p,v]: succeeds pos(?p) => terminates min_max(?p,?x,?v)) &
    (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?x,?v) &
       terminates max_list(?l,?x,?v)),
    succeeds nat(?x)],
   [assume(succeeds pos(?p),
     [terminates and_pos(?p) by axiom(and_pos:termination),
      assume(succeeds and_pos(?p),
       [terminates moves(?p,?l) by axiom(moves:termination),
        assume(succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
          all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?x,?v) &
            terminates max_list(?l,?x,?v),
	 terminates min_list(?l,?x,?v) & terminates max_list(?l,?x,?v), 
         terminates min_list(?l,?x,?v)],
         terminates min_list(?l,?x,?v)),
        terminates (moves(?p,?l) & min_list(?l,?x,?v))],
       terminates (moves(?p,?l) & min_list(?l,?x,?v))),
      terminates (and_pos(?p) & moves(?p,?l) & min_list(?l,?x,?v)),
      terminates or_pos(?p) by axiom(or_pos:termination),
      assume(succeeds or_pos(?p),
       [terminates moves(?p,?l) by axiom(moves:termination),
        assume(succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
	  all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?x,?v) &
            terminates max_list(?l,?x,?v),
	  terminates min_list(?l,?x,?v) & terminates max_list(?l,?x,?v),
          terminates max_list(?l,?x,?v)],
         terminates max_list(?l,?x,?v)),
        terminates (moves(?p,?l) & max_list(?l,?x,?v))],
       terminates (moves(?p,?l) & max_list(?l,?x,?v))),
      terminates (or_pos(?p) & moves(?p,?l) & max_list(?l,?x,?v)),
      (all l: terminates (and_pos(?p) & moves(?p,?l) & min_list(?l,?x,?v))) &
      (all l: terminates (or_pos(?p) & moves(?p,?l) & max_list(?l,?x,?v))),
      terminates min_max(?p,s(?x),?v) by completion],
     terminates min_max(?p,s(?x),?v)),
    all [p,v]: succeeds pos(?p) => terminates min_max(?p,s(?x),?v),
    /** As we have proved I(n) to I(n+1) we can assume it as given.
    Now once again I(l) is called. */
    induction(
     [all l: succeeds pos_list(?l) => 
	(all v: terminates min_list(?l,s(?x),?v) &
	  terminates max_list(?l,s(?x),?v))],
     /** Like in mathemathics first I([]). */
     [step([],
       [],
       terminates min_list([],s(?x),?v) & terminates max_list([],s(?x),?v),
       all v: terminates min_list([],s(?x),?v) &
	terminates max_list([],s(?x),?v)),
      /** Then I([x|l]). */
      step([0,l],
       [all v: terminates min_list(?l,s(?x),?v) &
	 terminates max_list(?l,s(?x),?v),
	succeeds pos(?0),
	succeeds pos_list(?l)],
       [assume(succeeds min_max(?0,s(?x),?v1),
	 [succeeds val(?v1) by corollary(min_max:types),
          all v2: terminates min_list(?l,s(?x),?v2) &
           terminates max_list(?l,s(?x),?v2),
          terminates min_list(?l,s(?x),?v2) &
          terminates max_list(?l,s(?x),?v2),
          terminates min_list(?l,s(?x),?v2),
          assume(succeeds min_list(?l,s(?x),?v2),
           [succeeds val(?v2) by corollary(min_list:types),
	    terminates min(?v1,?v2,?v) by lemma(min:termination)],
           terminates min(?v1,?v2,?v)),
          terminates (min_list(?l,s(?x),?v2) & min(?v1,?v2,?v))],
	 terminates (min_list(?l,s(?x),?v2) & min(?v1,?v2,?v))),
	terminates 
	(min_max(?0,s(?x),?v1) & min_list(?l,s(?x),?v2) & min(?v1,?v2,?v)),
	all [v1,v2]: 
	 terminates 
	 (min_max(?0,s(?x),?v1) & min_list(?l,s(?x),?v2) & min(?v1,?v2,?v)),
	terminates min_list([?0|?l],s(?x),?v) by completion,
	assume(succeeds min_max(?0,s(?x),?v1),
	 [succeeds val(?v1) by corollary(min_max:types),
          all v2: terminates min_list(?l,s(?x),?v2) &
           terminates max_list(?l,s(?x),?v2),
          terminates min_list(?l,s(?x),?v2) &
          terminates max_list(?l,s(?x),?v2),
          terminates max_list(?l,s(?x),?v2),
          assume(succeeds max_list(?l,s(?x),?v2),
           [succeeds val(?v2) by corollary(max_list:types),
	    terminates max(?v1,?v2,?v) by lemma(max:termination)],
           terminates max(?v1,?v2,?v)),
          terminates (max_list(?l,s(?x),?v2) & max(?v1,?v2,?v))],
	 terminates (max_list(?l,s(?x),?v2) & max(?v1,?v2,?v))),
	terminates 
	(min_max(?0,s(?x),?v1) & max_list(?l,s(?x),?v2) & max(?v1,?v2,?v)),
	all [v1,v2]: 
	 terminates 
	 (min_max(?0,s(?x),?v1) & max_list(?l,s(?x),?v2) & max(?v1,?v2,?v)),
	terminates max_list([?0|?l],s(?x),?v) by completion,
	terminates min_list([?0|?l],s(?x),?v) &
	terminates max_list([?0|?l],s(?x),?v)],
       all v: terminates min_list([?0|?l],s(?x),?v) &
	terminates max_list([?0|?l],s(?x),?v))]),
    assume(succeeds pos_list(?l),
     [all v: terminates min_list(?l,s(?x),?v) &
       terminates max_list(?l,s(?x),?v),
      terminates min_list(?l,s(?x),?v) & terminates max_list(?l,s(?x),?v)],
     terminates min_list(?l,s(?x),?v) & terminates max_list(?l,s(?x),?v))],
   (all [p,v]: succeeds pos(?p) => terminates min_max(?p,s(?x),?v)) &
   (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,s(?x),?v) &
      terminates max_list(?l,s(?x),?v)))])
).

/** Now we have the lemma for termination, we can prove some
corollaries needed later, like:
The termination of <TT>min_max/3</TT>. */

:- corollary(min_max:termination,
all [p,n,v]: succeeds pos(?p) & succeeds nat(?n) =>
  terminates min_max(?p,?n,?v),
assume(succeeds pos(?p) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
    (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
       terminates max_list(?l,?n,?v)) by lemma(min_max:termination),
  (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
  (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
     terminates max_list(?l,?n,?v)),
  all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v),
  terminates min_max(?p,?n,?v)],
 terminates min_max(?p,?n,?v))
).

/** The termination of <TT>min_list/3</TT>. */

:- corollary(min_list:termination,
all [l,n,v]: succeeds pos_list(?l) & succeeds nat(?n) =>
  terminates min_list(?l,?n,?v),
assume(succeeds pos_list(?l) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
    (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
       terminates max_list(?l,?n,?v)) by lemma(min_max:termination),
  (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
  (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
     terminates max_list(?l,?n,?v)),
  all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
     terminates max_list(?l,?n,?v),
  terminates min_list(?l,?n,?v) & terminates max_list(?l,?n,?v),
  terminates min_list(?l,?n,?v)],
 terminates min_list(?l,?n,?v))
).

/** Termination of <TT>max_list/3</TT>. */

:- corollary(max_list:termination,
all [l,n,v]: succeeds pos_list(?l) & succeeds nat(?n) =>
  terminates max_list(?l,?n,?v),
assume(succeeds pos_list(?l) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
    (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
       terminates max_list(?l,?n,?v)) by lemma(min_max:termination),
  (all [p,v]: succeeds pos(?p) => terminates min_max(?p,?n,?v)) &
  (all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
     terminates max_list(?l,?n,?v)),
  all [l,v]: succeeds pos_list(?l) => terminates min_list(?l,?n,?v) &
     terminates max_list(?l,?n,?v),
  terminates min_list(?l,?n,?v) & terminates max_list(?l,?n,?v),
  terminates max_list(?l,?n,?v)],
 terminates max_list(?l,?n,?v))
).

/** Existence of <TT>min_max/3</TT>, <TT>min_list/3</TT>,
<TT>max_list/3</TT>. */

/** Like for <TT>min/3</TT> or <TT>max/3</TT> it is important to assure
the existence of an evaluation for a position. */

/** For all natural n and for all positions p it exists a value v
(type assured by corollary(min_max:types)) so <TT>min_max/3</TT> succeeds. 
And for all natural n and for all position list l it exists a
value v (type assured by corollary(min_list:types) and 
corollary(max_list:types)) so <TT>min_list/3</TT> and <TT>max_list/3</TT> 
succeed. We prove it by a two level induction. First I(n). */ 

:- lemma(min_max:existence,
all n: succeeds nat(?n) =>
  (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
  (all l: succeeds pos_list(?l) =>
     (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v))),
induction(
 [all n: succeeds nat(?n) => 
    (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
    (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
       (ex v: succeeds max_list(?l,?n,?v)))],
 /** For n = 0 the proof is a triviality. */
 [step([],
   [],
   [assume(succeeds pos(?p),
     [ex v: succeeds static_value(?p,?v) by 
       axiom(static_value:existence),
      exist(v,
       succeeds static_value(?p,?v),
       [succeeds min_max(?p,0,?v),
	ex v: succeeds min_max(?p,0,?v)],
       ex v: succeeds min_max(?p,0,?v))],
     ex v: succeeds min_max(?p,0,?v)),
    all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,0,?v)),
    /** As we have I(0) we can assume it as given for <TT>min_max/3</TT> and 
    prove I(0) for <TT>min_list/3</TT> and <TT>max_list/3</TT> by induction 
    over the length of the position list. */   
    induction(
     [all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,0,?v)) &
	(ex v: succeeds max_list(?l,0,?v))],
     /** Now we know n = 0 and we assume l = [] so we prove I([]). */ 
     [step([],
       [],
       [succeeds min_list([],0,top),
        ex v: succeeds min_list([],0,?v),
	succeeds max_list([],0,bot),
        ex v: succeeds max_list([],0,?v)],
       (ex v: succeeds min_list([],0,?v)) &
       (ex v: succeeds max_list([],0,?v))),
      /** Still for n = 0 we prove I([x|l]). */ 
      step([x,l],
       [(ex v: succeeds min_list(?l,0,?v)) &
	(ex v: succeeds max_list(?l,0,?v)),
	succeeds pos(?x),
	succeeds pos_list(?l)],
       [(ex v: succeeds min_list(?l,0,?v)) &
	(ex v: succeeds max_list(?l,0,?v)),
        ex v: succeeds min_list(?l,0,?v),
        exist(v,
         succeeds min_list(?l,0,?v),
         [succeeds val(?v) by corollary(min_list:types),
	  all x: succeeds pos(?x) => (ex v1: succeeds min_max(?x,0,?v1)),
          ex v1: succeeds min_max(?x,0,?v1),
          exist(v1,
           succeeds min_max(?x,0,?v1),
           [succeeds val(?v1) by corollary(min_max:types),
	    ex u: succeeds min(?v1,?v,?u) by lemma(min:existence),
            exist(u,
             succeeds min(?v1,?v,?u),
             [succeeds min_list([?x|?l],0,?u),
	      ex v: succeeds min_list([?x|?l],0,?v)],
             ex v: succeeds min_list([?x|?l],0,?v))],
           ex v: succeeds min_list([?x|?l],0,?v))],
         ex v: succeeds min_list([?x|?l],0,?v)),
	 (ex v: succeeds min_list(?l,0,?v)) &
	 (ex v: succeeds max_list(?l,0,?v)),
	 ex v: succeeds max_list(?l,0,?v),
         exist(v,
          succeeds max_list(?l,0,?v),
          [succeeds val(?v) by corollary(max_list:types),
	   all x: succeeds pos(?x) => (ex v1: succeeds min_max(?x,0,?v1)),
           ex v1: succeeds min_max(?x,0,?v1),
           exist(v1,
            succeeds min_max(?x,0,?v1),
            [succeeds val(?v1) by corollary(min_max:types),
	     ex u: succeeds max(?v1,?v,?u) by lemma(max:existence),
             exist(u,
              succeeds max(?v1,?v,?u),
              [succeeds max_list([?x|?l],0,?u),
	       ex v: succeeds max_list([?x|?l],0,?v)],
              ex v: succeeds max_list([?x|?l],0,?v))],
            ex v: succeeds max_list([?x|?l],0,?v))],
          ex v: succeeds max_list([?x|?l],0,?v))],
       (ex v: succeeds min_list([?x|?l],0,?v)) &
       (ex v: succeeds max_list([?x|?l],0,?v)))]),
    assume(succeeds pos_list(?l),
     [(ex v: succeeds min_list(?l,0,?v)) &
      (ex v: succeeds max_list(?l,0,?v)),
      (ex v: succeeds min_list(?l,0,?v)) &
      (ex v: succeeds max_list(?l,0,?v))],
     (ex v: succeeds min_list(?l,0,?v)) &
     (ex v: succeeds max_list(?l,0,?v)))],
   (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,0,?v))) &
   (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,0,?v)) &
      (ex v: succeeds max_list(?l,0,?v)))),
  /** Here begins the inductionstep I(n) to I(n+1). */
  step([x],
   [(all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?x,?v))) &
    (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?x,?v)) &
       (ex v: succeeds max_list(?l,?x,?v))),
    succeeds nat(?x)],
   [assume(succeeds pos(?p),
     [ex l: succeeds moves(?p,?l) by axiom(moves:existence),
      exist(l,
       succeeds moves(?p,?l),
       [succeeds pos_list(?l) by axiom(moves:list:types),
	succeeds and_pos(?p) \/ succeeds or_pos(?p) by axiom(pos:total),
        /** We have to distinguish between a and node and or node. */
        cases(succeeds and_pos(?p),
         [all l: succeeds pos_list(?l) => 
            (ex v1: succeeds min_list(?l,?x,?v1)) &
            (ex v1: succeeds max_list(?l,?x,?v1)),
	  (ex v1: succeeds min_list(?l,?x,?v1)) &
          (ex v1: succeeds max_list(?l,?x,?v1)),
         ex v1: succeeds min_list(?l,?x,?v1),
         exist(v1,
          succeeds min_list(?l,?x,?v1),
          [succeeds min_max(?p,s(?x),?v1),
	   ex v: succeeds min_max(?p,s(?x),?v)],
          ex v: succeeds min_max(?p,s(?x),?v))],
         succeeds or_pos(?p),
         [all l: succeeds pos_list(?l) => 
            (ex v1: succeeds min_list(?l,?x,?v1)) &
            (ex v1: succeeds max_list(?l,?x,?v1)),
	  (ex v1: succeeds min_list(?l,?x,?v1)) &
          (ex v1: succeeds max_list(?l,?x,?v1)),
	  ex v1: succeeds max_list(?l,?x,?v1),
          exist(v1,
           succeeds max_list(?l,?x,?v1),
           [succeeds min_max(?p,s(?x),?v1),
	    ex v: succeeds min_max(?p,s(?x),?v)],
           ex v: succeeds min_max(?p,s(?x),?v))],
         ex v: succeeds min_max(?p,s(?x),?v))],
       ex v: succeeds min_max(?p,s(?x),?v))],
     ex v: succeeds min_max(?p,s(?x),?v)),
    all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,s(?x),?v)),
    /** We proved the inductionstep I(n) to I(n+1) for <TT>min_max/3</TT>.
    So we can assume it as given and start the induction for I(l). */
    induction(
     [all l: succeeds pos_list(?l) => 
	(ex v: succeeds min_list(?l,s(?x),?v)) &
	(ex v: succeeds max_list(?l,s(?x),?v))],
     /** l = [] */
     [step([],
       [],
       [succeeds min_list([],s(?x),top),
        ex v: succeeds min_list([],s(?x),?v),
	succeeds max_list([],s(?x),bot),
        ex v: succeeds max_list([],s(?x),?v)],
       (ex v: succeeds min_list([],s(?x),?v)) &
       (ex v: succeeds max_list([],s(?x),?v))),
      /** Inductionstep I(l) to I([x|l]) by given I(n) for <TT>min_max/3</TT>,
      <TT>min_list/3</TT> and <TT>max_list/3</TT>. */
      step([0,l],
       [(ex v: succeeds min_list(?l,s(?x),?v)) &
	(ex v: succeeds max_list(?l,s(?x),?v)),
	succeeds pos(?0),
	succeeds pos_list(?l)],
       [all 0: succeeds pos(?0) => (ex v1: succeeds min_max(?0,s(?x),?v1)),
        ex v1: succeeds min_max(?0,s(?x),?v1),
        exist(v1,
         succeeds min_max(?0,s(?x),?v1),
         [succeeds val(?v1) by corollary(min_max:types),
	  (ex v: succeeds min_list(?l,s(?x),?v)) &
	  (ex v: succeeds max_list(?l,s(?x),?v)),
          ex v: succeeds min_list(?l,s(?x),?v), 
          exist(v,
           succeeds min_list(?l,s(?x),?v),
           [succeeds val(?v) by corollary(min_list:types),
	    ex u: succeeds min(?v1,?v,?u) by lemma(min:existence),
            exist(u,
             succeeds min(?v1,?v,?u),
             [succeeds min_list([?0|?l],s(?x),?u),
	      ex v: succeeds min_list([?0|?l],s(?x),?v)],
             ex v: succeeds min_list([?0|?l],s(?x),?v))],
           ex v: succeeds min_list([?0|?l],s(?x),?v))],
         ex v: succeeds min_list([?0|?l],s(?x),?v)),
        all 0: succeeds pos(?0) => (ex v1: succeeds min_max(?0,s(?x),?v1)),
        ex v1: succeeds min_max(?0,s(?x),?v1),
	exist(v1,
         succeeds min_max(?0,s(?x),?v1),
         [succeeds val(?v1) by corollary(min_max:types),
          (ex v: succeeds min_list(?l,s(?x),?v)) &
	  (ex v: succeeds max_list(?l,s(?x),?v)),
          ex v: succeeds max_list(?l,s(?x),?v),
	  exist(v,
           succeeds max_list(?l,s(?x),?v),
           [succeeds val(?v) by corollary(max_list:types),
            ex u: succeeds max(?v1,?v,?u) by lemma(max:existence),
	    exist(u,
             succeeds max(?v1,?v,?u),
             [succeeds max_list([?0|?l],s(?x),?u),
	      ex v: succeeds max_list([?0|?l],s(?x),?v)],
             ex v: succeeds max_list([?0|?l],s(?x),?v))],
           ex v: succeeds max_list([?0|?l],s(?x),?v))],
         ex v: succeeds max_list([?0|?l],s(?x),?v))],
       (ex v: succeeds min_list([?0|?l],s(?x),?v)) &
       (ex v: succeeds max_list([?0|?l],s(?x),?v)))]),
    assume(succeeds pos_list(?l),
     [(ex v: succeeds min_list(?l,s(?x),?v)) &
      (ex v: succeeds max_list(?l,s(?x),?v)),
      (ex v: succeeds min_list(?l,s(?x),?v)) &
      (ex v: succeeds max_list(?l,s(?x),?v))],
     (ex v: succeeds min_list(?l,s(?x),?v)) &
     (ex v: succeeds max_list(?l,s(?x),?v)))],
   (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,s(?x),?v))) &
   (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,s(?x),?v)) &
      (ex v: succeeds max_list(?l,s(?x),?v))))])
).

/** The following corollary is only a simpler formulation for the
preceeding lemma. And it is only correct for <TT>min_max/3</TT>. */

:- corollary(min_max:existence,
all [p,n]: succeeds pos(?p) & succeeds nat(?n) =>
  (ex v: succeeds min_max(?p,?n,?v)),
assume(succeeds pos(?p) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
    (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
       (ex v: succeeds max_list(?l,?n,?v))) by lemma(min_max:existence),
  (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
  (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v))),
  all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v)),
  ex v: succeeds min_max(?p,?n,?v)],
 ex v: succeeds min_max(?p,?n,?v))
).

/** Existence of an evaluation for <TT>min_list/3</TT>. */

:- corollary(min_list:existence,
all [l,n]: succeeds pos_list(?l) & succeeds nat(?n) =>
  (ex v: succeeds min_list(?l,?n,?v)),
assume(succeeds pos_list(?l) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
    (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
       (ex v: succeeds max_list(?l,?n,?v))) by lemma(min_max:existence),
  (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
  (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v))),
  all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v)),
   (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v)),
  ex v: succeeds min_list(?l,?n,?v)],
 ex v: succeeds min_list(?l,?n,?v))
).

/** Existence of an evaluation for <TT>max_list/3</TT>. */

:- corollary(max_list:existence,
all [l,n]: succeeds pos_list(?l) & succeeds nat(?n) =>
  (ex v: succeeds max_list(?l,?n,?v)),
assume(succeeds pos_list(?l) & succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
    (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
       (ex v: succeeds max_list(?l,?n,?v))) by lemma(min_max:existence),
  (all p: succeeds pos(?p) => (ex v: succeeds min_max(?p,?n,?v))) &
  (all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v))),
  all l: succeeds pos_list(?l) => (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v)),
   (ex v: succeeds min_list(?l,?n,?v)) &
     (ex v: succeeds max_list(?l,?n,?v)),
  ex v: succeeds max_list(?l,?n,?v)],
 ex v: succeeds max_list(?l,?n,?v))
).

/** Uniqueness of <TT>min_max/3</TT>, <TT>min_list/3</TT>,
<TT>max_list/3</TT>. */

/** Having the existence of an evaluation for any position, the 
evaluation has to be unique. What means that for the same game postion
the algorithm has to give the same evaluation. The proof works again
over two levels. First level is the natural n and the second level
is the length of the position list.*/

/** The algorithm starts and returns for all p,l,n a value v. We
start it again and the algorithm returns for the same parameters 
a value v1. Now we have to prove, by induction on the length of the 
same parameters, that for <TT>min_max/3</TT>, <TT>min_list/3</TT> 
and <TT>max_list/3</TT> v = v1. */ 

:- lemma(min_max:uniqueness,
(all [p,n,v]: succeeds min_max(?p,?n,?v) =>
   (succeeds pos(?p) => (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1))) &
(all [l,n,v]: succeeds min_list(?l,?n,?v) =>
   (succeeds pos_list(?l) =>
     (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1))) &
(all [l,n,v]: succeeds max_list(?l,?n,?v) =>
   (succeeds pos_list(?l) =>
     (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1))),
induction(
 [all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
     (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1),
  all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
     (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1),
  all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
     (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1)],
 [step([p,v],
   [succeeds static_value(?p,?v)],
   assume(succeeds pos(?p),
    assume(succeeds min_max(?p,0,?v1),
     [def succeeds min_max(?p,0,?v1) by completion,
      succeeds static_value(?p,?v1),
      ?v = ?v1 by axiom(static_value:uniqueness)],
     ?v = ?v1),
    all v1: succeeds min_max(?p,0,?v1) => ?v = ?v1),
   succeeds pos(?p) => (all v1: succeeds min_max(?p,0,?v1) => ?v = ?v1)),
  step([p,n,v,l],
   [succeeds pos_list(?l) => 
     (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1),
    succeeds and_pos(?p),
    succeeds moves(?p,?l),
    succeeds min_list(?l,?n,?v)],
   assume(succeeds pos(?p),
    assume(succeeds min_max(?p,s(?n),?v1),
     [def succeeds min_max(?p,s(?n),?v1) by completion,
      cases(
       ex l: succeeds and_pos(?p) & succeeds moves(?p,?l) &
        succeeds min_list(?l,?n,?v1),
       exist(0,
        succeeds and_pos(?p) & succeeds moves(?p,?0) &
        succeeds min_list(?0,?n,?v1),
        [?0 = ?l by axiom(moves:uniqueness),
	 succeeds min_list(?l,?n,?v1),
         succeeds pos_list(?l) by axiom(moves:list:types),
         succeeds pos_list(?l) => 
          (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1),
         all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1,
         ?v = ?v1],
        ?v = ?v1),
       ex l: succeeds or_pos(?p) & succeeds moves(?p,?l) &
        succeeds max_list(?l,?n,?v1),
       exist(0,
        succeeds or_pos(?p) & succeeds moves(?p,?0) &
        succeeds max_list(?0,?n,?v1),
        [succeeds and_pos(?p) & succeeds or_pos(?p),
         all p: succeeds pos(?p) => 
           ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by 
          axiom(pos:disjoint),
	 ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by 
          axiom(pos:disjoint),
         ?v = ?v1],
        ?v = ?v1),
       ?v = ?v1)],
     ?v = ?v1),
    all v1: succeeds min_max(?p,s(?n),?v1) => ?v = ?v1),
   succeeds pos(?p) => 
    (all v1: succeeds min_max(?p,s(?n),?v1) => ?v = ?v1)),
  step([p,n,v,l],
   [succeeds pos_list(?l) => 
     (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1),
    succeeds or_pos(?p),
    succeeds moves(?p,?l),
    succeeds max_list(?l,?n,?v)],
   assume(succeeds pos(?p),
    assume(succeeds min_max(?p,s(?n),?v1),
     [def succeeds min_max(?p,s(?n),?v1) by completion,
      cases(
       ex l: succeeds and_pos(?p) & succeeds moves(?p,?l) &
        succeeds min_list(?l,?n,?v1),
       exist(0,
        succeeds and_pos(?p) & succeeds moves(?p,?0) &
        succeeds min_list(?0,?n,?v1),
        [succeeds and_pos(?p) & succeeds or_pos(?p),
         all p: succeeds pos(?p) => 
           ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by 
          axiom(pos:disjoint),
	 ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by 
          axiom(pos:disjoint),
	 ?v = ?v1],
        ?v = ?v1),
       ex l: succeeds or_pos(?p) & succeeds moves(?p,?l) &
        succeeds max_list(?l,?n,?v1),
       exist(0,
        succeeds or_pos(?p) & succeeds moves(?p,?0) &
        succeeds max_list(?0,?n,?v1),
        [?0 = ?l by axiom(moves:uniqueness),
	 succeeds pos_list(?l) by axiom(moves:list:types),
         succeeds max_list(?l,?n,?v1),
         succeeds pos_list(?l) => 
          (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1),
         all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1,
         ?v = ?v1],
        ?v = ?v1),
       ?v = ?v1)],
     ?v = ?v1),
    all v1: succeeds min_max(?p,s(?n),?v1) => ?v = ?v1),
   succeeds pos(?p) => 
    (all v1: succeeds min_max(?p,s(?n),?v1) => ?v = ?v1)),
  step([0],
   [],
   assume(succeeds pos_list([]),
    assume(succeeds min_list([],?0,?v1),
     [def succeeds min_list([],?0,?v1) by completion,top = ?v1],
     top = ?v1),
    all v1: succeeds min_list([],?0,?v1) => top = ?v1),
   succeeds pos_list([]) => 
    (all v1: succeeds min_list([],?0,?v1) => top = ?v1)),
  step([x,l,n,v,v1,v2],
   [succeeds pos(?x) => (all 0: succeeds min_max(?x,?n,?0) => ?v1 = ?0),
    succeeds pos_list(?l) => 
     (all v1: succeeds min_list(?l,?n,?v1) => ?v2 = ?v1),
    succeeds min_max(?x,?n,?v1),
    succeeds min_list(?l,?n,?v2),
    succeeds min(?v1,?v2,?v)],
   assume(succeeds pos_list([?x|?l]),
    [assume(succeeds min_list([?x|?l],?n,?0),
      [def succeeds pos_list([?x|?l]) by completion,succeeds pos(?x),
       def succeeds min_list([?x|?l],?n,?0) by completion,
       exist([1,2],
	succeeds min_max(?x,?n,?1) & succeeds min_list(?l,?n,?2) &
	succeeds min(?1,?2,?0),
	[succeeds min_max(?x,?n,?v1),
         succeeds pos(?x) => (all 1: succeeds min_max(?x,?n,?1) => ?v1 = ?1),
         all 1: succeeds min_max(?x,?n,?1) => ?v1 = ?1,
         ?v1 = ?1,
         succeeds pos_list(?l),
         succeeds min_list(?l,?n,?v2),
         succeeds pos_list(?l) => 
         (all 2: succeeds min_list(?l,?n,?2) => ?v2 = ?2),
         all 2: succeeds min_list(?l,?n,?2) => ?v2 = ?2,
         ?v2 = ?2,
         succeeds min(?v1,?v2,?0),
         succeeds min(?v1,?v2,?v),
	 def succeeds min(?v1,?v2,?v) by completion,
	 cases(succeeds ?v1 #=< ?v2 & ?v = ?v1,
	  [def succeeds min(?v1,?v2,?0) by completion,
           cases(succeeds ?v1 #=< ?v2 & ?0 = ?v1,
            [],
            fails ?v1 #=< ?v2 & ?0 = ?v2,
            [],
            ?v = ?0)],
	  fails ?v1 #=< ?v2 & ?v = ?v2,
	  [def succeeds min(?v1,?v2,?0) by completion,
           cases(succeeds ?v1 #=< ?v2 & ?0 = ?v1,
            [],
            fails ?v1 #=< ?v2 & ?0 = ?v2,
            [],
            ?v = ?0)],
	  ?v = ?0)],
	?v = ?0)],
      ?v = ?0),
     all 0: succeeds min_list([?x|?l],?n,?0) => ?v = ?0],
    all v1: succeeds min_list([?x|?l],?n,?v1) => ?v = ?v1),
   succeeds pos_list([?x|?l]) => 
    (all v1: succeeds min_list([?x|?l],?n,?v1) => ?v = ?v1)),
  step([0],
   [],
   assume(succeeds pos_list([]),
    assume(succeeds max_list([],?0,?v1),
     [def succeeds max_list([],?0,?v1) by completion,bot = ?v1],
     bot = ?v1),
    all v1: succeeds max_list([],?0,?v1) => bot = ?v1),
   succeeds pos_list([]) => 
    (all v1: succeeds max_list([],?0,?v1) => bot = ?v1)),
  step([x,l,n,v,v1,v2],
   [succeeds pos(?x) => (all 0: succeeds min_max(?x,?n,?0) => ?v1 = ?0),
    succeeds pos_list(?l) => 
     (all v1: succeeds max_list(?l,?n,?v1) => ?v2 = ?v1),
    succeeds min_max(?x,?n,?v1),
    succeeds max_list(?l,?n,?v2),
    succeeds max(?v1,?v2,?v)],
   assume(succeeds pos_list([?x|?l]),
    [assume(succeeds max_list([?x|?l],?n,?0),
      [def succeeds pos_list([?x|?l]) by completion,succeeds pos(?x),
       def succeeds max_list([?x|?l],?n,?0) by completion,
       exist([1,2],
	succeeds min_max(?x,?n,?1) & succeeds max_list(?l,?n,?2) &
	succeeds max(?1,?2,?0),
	[succeeds pos(?x) => (all 1: succeeds min_max(?x,?n,?1) => ?v1 = ?1),
         all 1: succeeds min_max(?x,?n,?1) => ?v1 = ?1,
         ?v1 = ?1,
         succeeds pos_list(?l),
         succeeds pos_list(?l) => 
         (all 2: succeeds max_list(?l,?n,?2) => ?v2 = ?2),
         all 2: succeeds max_list(?l,?n,?2) => ?v2 = ?2,
         ?v2 = ?2,
         succeeds max(?v1,?v2,?0), 
         succeeds max(?v1,?v2,?v),
	 def succeeds max(?v1,?v2,?v) by completion,
	 cases(succeeds ?v1 #=< ?v2 & ?v = ?v2,
	  [def succeeds max(?v1,?v2,?0) by completion,
           cases(succeeds ?v1 #=< ?v2 & ?0 = ?v2,
            [],
            fails ?v1 #=< ?v2 & ?0 = ?v1,
            [],
            ?v = ?0)],
	  fails ?v1 #=< ?v2 & ?v = ?v1,
	  [def succeeds max(?v1,?v2,?0) by completion,
           cases(succeeds ?v1 #=< ?v2 & ?0 = ?v2,
            [],
            fails ?v1 #=< ?v2 & ?0 = ?v1,
            [],
            ?v = ?0)],
	  ?v = ?0)],
	?v = ?0)],
      ?v = ?0),
     all 0: succeeds max_list([?x|?l],?n,?0) => ?v = ?0],
    all v1: succeeds max_list([?x|?l],?n,?v1) => ?v = ?v1),
   succeeds pos_list([?x|?l]) => 
    (all v1: succeeds max_list([?x|?l],?n,?v1) => ?v = ?v1))])
).

/** Because the algorithm is defined recursively you cannot prove 
seperatly uniqueness for <TT>min_max/3</TT>. But after having proven 
the preceeding lemma, you can easily succeed the uniqueness 
of <TT>min_max/3</TT>.  */

:- corollary(min_max:uniqueness,
all [p,n,v,v1]: succeeds pos(?p) & succeeds min_max(?p,?n,?v) &
 succeeds min_max(?p,?n,?v1) => ?v = ?v1,
assume(succeeds pos(?p) & succeeds min_max(?p,?n,?v) &
 succeeds min_max(?p,?n,?v1),
 [(all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
      (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1)) by 
   lemma(min_max:uniqueness),
  all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
      (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1),
  succeeds pos(?p) => 
      (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1),
  all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** Now the uniqueness of <TT>min_list/3</TT>. */

:- corollary(min_list:uniqueness,
all [l,n,v,v1]: succeeds pos_list(?l) & succeeds min_list(?l,?n,?v) &
 succeeds min_list(?l,?n,?v1) => ?v = ?v1,
assume(succeeds pos_list(?l) & succeeds min_list(?l,?n,?v) &
 succeeds min_list(?l,?n,?v1),
 [(all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
      (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1)) by 
   lemma(min_max:uniqueness),
  all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1),
  succeeds pos_list(?l) => 
      (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1),
  all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** And finally the uniqueness of <TT>max_list/3</TT>. */

:- corollary(max_list:uniqueness,
all [l,n,v,v1]: succeeds pos_list(?l) & succeeds max_list(?l,?n,?v) &
 succeeds max_list(?l,?n,?v1) => ?v = ?v1,
assume(succeeds pos_list(?l) & succeeds max_list(?l,?n,?v) &
 succeeds max_list(?l,?n,?v1),
 [(all [p,n,v]: succeeds min_max(?p,?n,?v) => succeeds pos(?p) => 
      (all v1: succeeds min_max(?p,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds min_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds min_list(?l,?n,?v1) => ?v = ?v1)) &
  (all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1)) by 
   lemma(min_max:uniqueness),
  all [l,n,v]: succeeds max_list(?l,?n,?v) => succeeds pos_list(?l) => 
      (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1),
  succeeds pos_list(?l) => 
      (all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1),
  all v1: succeeds max_list(?l,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** We can introduce function symbols for <TT>min_max/3</TT>, 
<TT>min_list/3</TT>, <TT>max_list/3</TT>. 
We can only introduce them if we have proven existence and
uniqueness of the defined functions. Else <TT>LPTP</TT> would not accept 
them. */

/** For <TT>min_max/3</TT> we define a function symbol <TT>mm/2</TT>. */

:- definition_fun(mm,2,
all [p,n,v]: succeeds pos(?p) & succeeds nat(?n) =>
  (mm(?p,?n) = ?v <=> succeeds min_max(?p,?n,?v)),
existence by corollary(min_max:existence),
uniqueness by corollary(min_max:uniqueness)
).

/** For <TT>min_list/3</TT> we define a function symbol <TT>mil/2</TT>. */

:- definition_fun(mil,2,
all [l,n,v]: succeeds pos_list(?l) & succeeds nat(?n) =>
  (mil(?l,?n) = ?v <=> succeeds min_list(?l,?n,?v)),
existence by corollary(min_list:existence),
uniqueness by corollary(min_list:uniqueness)
).

/** For <TT>max_list/3</TT> we define a function symbol <TT>mal/2</TT>. */

:- definition_fun(mal,2,
all [l,n,v]: succeeds pos_list(?l) & succeeds nat(?n) =>
  (mal(?l,?n) = ?v <=> succeeds max_list(?l,?n,?v)),
existence by corollary(max_list:existence),
uniqueness by corollary(max_list:uniqueness)
).

/** Properties of the functions <TT>mm</TT>, <TT>mil</TT>, <TT>mal</TT>. */

% Jetzt endlich kommen die Eigenschaften (1) - (7) von meinen Notitzen.

/** Some implicit properties we proved already in the preceeding lemmas
we want to assure also for the function symbols.
The first is the following. */

/** For all positions p and if n = 0 then <TT>mm(p,0) = sv(p)</TT>. Like the
prolog code would ask it. */ 

:- lemma(mm:zero,
all p: succeeds pos(?p) => mm(?p,0) = sv(?p),
assume(succeeds pos(?p),
 [succeeds static_value(?p,sv(?p)) by existence(sv,1),
  succeeds min_max(?p,0,sv(?p)) by completion,
  mm(?p,0) = sv(?p) by uniqueness(mm,2)],
 mm(?p,0) = sv(?p))
).

/** We have already needed the fact that a position can be either an
AND node or an OR node. So not having always to prove logical properties, 
we do it here once. */

/** If we are on an AND node (~and_pos) in the game tree, the value of
<TT>mm/2</TT> is the value returned by <TT>mil/2</TT>. */ 

:- lemma(mm:and_pos,
all [p,n]: succeeds pos(?p) & succeeds nat(?n) & succeeds and_pos(?p) =>
  mm(?p,s(?n)) = mil(ms(?p),?n),
assume(succeeds pos(?p) & succeeds nat(?n) & succeeds and_pos(?p),
 [succeeds pos_list(ms(?p)) by lemma(ms:types),
  succeeds min_list(ms(?p),?n,mil(ms(?p),?n)) by existence(mil,2),
  succeeds moves(?p,ms(?p)) by existence(ms,1),
  succeeds min_max(?p,s(?n),mil(ms(?p),?n)) by sld,
  mm(?p,s(?n)) = mil(ms(?p),?n) by uniqueness(mm,2)],
 mm(?p,s(?n)) = mil(ms(?p),?n))
).

/** If we are on an OR node (~or_pos) in the game tree, the value of
<TT>mm/2</TT> is the value returned by <TT>mal/2</TT>. */ 

:- lemma(mm:or_pos,
all [p,n]: succeeds pos(?p) & succeeds nat(?n) & succeeds or_pos(?p) =>
  mm(?p,s(?n)) = mal(ms(?p),?n),
assume(succeeds pos(?p) & succeeds nat(?n) & succeeds or_pos(?p),
 [succeeds pos_list(ms(?p)) by lemma(ms:types),
  succeeds max_list(ms(?p),?n,mal(ms(?p),?n)) by existence(mal,2),
  succeeds moves(?p,ms(?p)) by existence(ms,1),
  succeeds min_max(?p,s(?n),mal(ms(?p),?n)) by sld,
  mm(?p,s(?n)) = mal(ms(?p),?n) by uniqueness(mm,2)],
 mm(?p,s(?n)) = mal(ms(?p),?n))
).

/** If the list is empty the return value of <TT>mil/2</TT> is <TT>top</TT>, 
which means <TT>+infinity</TT> if the value was real. */

:- lemma(mil:empty,
all n: succeeds nat(?n) => mil([],?n) = top,
assume(succeeds nat(?n),
 mil([],?n) = top by uniqueness(mil,2),mil([],?n) = top)
).

/** You remember the two level induction we used to prove some facts.
Here we can make a summary for <TT>mil/2</TT>. mil/2 is a recursive function 
over a list [x|l] which returns the minimum of mm(x,n) and mil(l,n). */

:- lemma(mil:cons,
all [p,l,n]: succeeds pos(?p) & succeeds pos_list(?l) & succeeds nat(?n) =>
  mil([?p|?l],?n) = minf(mm(?p,?n),mil(?l,?n)),
assume(succeeds pos(?p) & succeeds pos_list(?l) & succeeds nat(?n),
 [succeeds min_max(?p,?n,mm(?p,?n)) by existence(mm,2),
  succeeds val(mm(?p,?n)) by corollary(min_max:types),
  succeeds min_list(?l,?n,mil(?l,?n)) by existence(mil,2),
  succeeds val(mil(?l,?n)) by corollary(min_list:types),
  succeeds min(mm(?p,?n),mil(?l,?n),minf(mm(?p,?n),mil(?l,?n))) by 
   existence(minf,2),
  succeeds min_list([?p|?l],?n,minf(mm(?p,?n),mil(?l,?n))),
  succeeds min_list([?p|?l],?n,mil([?p|?l],?n)) by existence(mil,2),
  mil([?p|?l],?n) = minf(mm(?p,?n),mil(?l,?n)) by uniqueness(mil,2)],
 mil([?p|?l],?n) = minf(mm(?p,?n),mil(?l,?n)))
).

/** If the list is empty the returned value of <TT>mal/2</TT> is <TT>bot</TT>,
which means <TT>-infinity</TT> if the value was real. */

:- lemma(mal:empty,
all n: succeeds nat(?n) => mal([],?n) = bot,
assume(succeeds nat(?n),
 mal([],?n) = bot by uniqueness(mal,2),mal([],?n) = bot)
).

/** Here we can make a summary for mal/2. mal/2 is a recursive function 
over a list [x|l] which returns the maximum of mm(x,n) and mal(l,n). */

:- lemma(mal:cons,
all [p,l,n]: succeeds pos(?p) & succeeds pos_list(?l) & succeeds nat(?n) =>
  mal([?p|?l],?n) = maxf(mm(?p,?n),mal(?l,?n)),
assume(succeeds pos(?p) & succeeds pos_list(?l) & succeeds nat(?n),
 [succeeds min_max(?p,?n,mm(?p,?n)) by existence(mm,2),
  succeeds val(mm(?p,?n)) by corollary(min_max:types),
  succeeds max_list(?l,?n,mal(?l,?n)) by existence(mal,2),
  succeeds val(mal(?l,?n)) by corollary(max_list:types),
  succeeds max(mm(?p,?n),mal(?l,?n),maxf(mm(?p,?n),mal(?l,?n))) by 
   existence(maxf,2),
  succeeds max_list([?p|?l],?n,maxf(mm(?p,?n),mal(?l,?n))),
  succeeds max_list([?p|?l],?n,mal([?p|?l],?n)) by existence(mal,2),
  mal([?p|?l],?n) = maxf(mm(?p,?n),mal(?l,?n)) by uniqueness(mal,2)],
 mal([?p|?l],?n) = maxf(mm(?p,?n),mal(?l,?n)))
).

/** Properties of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT> and
<TT>beta_list/5</TT>. */

/** Beside the <TT>min_max/3</TT> algorithm we defined the 
<TT>alpha_beta/5</TT>  algorithm, which evaluates also a value of a position. 
Now the type of the return value has to be of value. Next lemma assures it. */

/** Under the assumptions that for all positions p, position list l,
value a, value b and not specified natural n, we prove by 
induction on the length of those parameters that the return type
of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT> and 
<TT>beta_list/5</TT> is value. */

:- lemma(alpha_beta:types,
(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) =>
  (succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
    succeeds val(?v))) &
(all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) =>
   (succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) =>
     succeeds val(?v))) &
(all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) =>
   (succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) =>
     succeeds val(?v))),
induction(
 [all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos(?p) => succeeds val(?v),
  all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v),
  all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)],
 [step([0,1,p,v],
   [succeeds static_value(?p,?v)],
   assume(succeeds val(?0) & succeeds val(?1) & succeeds pos(?p),
    succeeds val(?v) by axiom(static_value:types),
    succeeds val(?v)),
   succeeds val(?0) & succeeds val(?1) & succeeds pos(?p) => 
    succeeds val(?v)),
  step([a,b,p,n,v,l],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
     succeeds val(?v),
    succeeds and_pos(?p),
    succeeds moves(?p,?l),
    succeeds beta_list(?a,?b,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
    succeeds val(?v) by axiom(moves:list:types),
    succeeds val(?v)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
    succeeds val(?v)),
  step([a,b,p,n,v,l],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
     succeeds val(?v),
    succeeds or_pos(?p),
    succeeds moves(?p,?l),
    succeeds alpha_list(?a,?b,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
    succeeds val(?v) by axiom(moves:list:types),
    succeeds val(?v)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
    succeeds val(?v)),
  step([a,b,l,0],
   [succeeds ?b #=< ?a \/ ?l = []],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l),
    [],
    succeeds val(?a)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
    succeeds val(?a)),
  step([a,b,p,l,n,v,v1,v2],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     succeeds val(?v1),
    succeeds val(?v2) & succeeds val(?b) & succeeds pos_list(?l) => 
     succeeds val(?v),
    succeeds ?a #< ?b,
    succeeds alpha_beta(?a,?b,?p,?n,?v1),
    succeeds max(?a,?v1,?v2),
    succeeds alpha_list(?v2,?b,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list([?p|?l]),
    [def succeeds pos_list([?p|?l]) by completion,
     succeeds pos(?p),
     succeeds val(?v1),
     succeeds pos_list(?l),
     succeeds val(?a),
     succeeds max(?a,?v1,?v2),
     def succeeds max(?a,?v1,?v2) by completion,
     cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
      [],
      fails ?a #=< ?v1 & ?v2 = ?a,
      [],
      succeeds val(?v))],
    succeeds val(?v)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos_list([?p|?l]) => 
    succeeds val(?v)),
  step([a,b,l,0],
   [succeeds ?b #=< ?a \/ ?l = []],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l),
    [],
    succeeds val(?b)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
    succeeds val(?b)),
  step([a,b,p,l,n,v,v1,v2],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     succeeds val(?v1),
    succeeds val(?a) & succeeds val(?v2) & succeeds pos_list(?l) => 
     succeeds val(?v),
    succeeds ?a #< ?b,
    succeeds alpha_beta(?a,?b,?p,?n,?v1),
    succeeds min(?b,?v1,?v2),
    succeeds beta_list(?a,?v2,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list([?p|?l]),
    [def succeeds pos_list([?p|?l]) by completion,
     succeeds pos(?p),
     succeeds val(?v1),
     succeeds pos_list(?l),
     succeeds val(?b),
     succeeds min(?b,?v1,?v2),
     def succeeds min(?b,?v1,?v2) by completion,
     cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
      [],
      fails ?b #=< ?v1 & ?v2 = ?v1,
      [],
      succeeds val(?v))],
    succeeds val(?v)),
   succeeds val(?a) & succeeds val(?b) & succeeds pos_list([?p|?l]) => 
    succeeds val(?v))])
).

/** Like for <TT>min_max/3</TT> the return type value of <TT>alpha_beta/5</TT> 
has to be known independantly of <TT>alpha_list/5</TT> and 
<TT>beta_list/5</TT>. */
  
:- corollary(alpha_beta:types,
all [a,b,p,n,v]: succeeds val(?a) & succeeds val(?b) & 
 succeeds pos(?p) &  succeeds alpha_beta(?a,?b,?p,?n,?v) => 
  succeeds val(?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds alpha_beta(?a,?b,?p,?n,?v),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) by 
   lemma(alpha_beta:types),
  all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos(?p) => succeeds val(?v),
  succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
   succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** So the return type of <TT>alpha_list/5</TT> is also value. */

:- corollary(alpha_list:types,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) & 
 succeeds pos_list(?l) &  succeeds alpha_list(?a,?b,?l,?n,?v) => 
  succeeds val(?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds alpha_list(?a,?b,?l,?n,?v),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) by 
   lemma(alpha_beta:types),
  all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v),
  succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
   succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** And finally the return type of <TT>beta_list/5</TT> is value. */

:- corollary(beta_list:types,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) & 
 succeeds pos_list(?l) &  succeeds beta_list(?a,?b,?l,?n,?v) => 
  succeeds val(?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds beta_list(?a,?b,?l,?n,?v),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) by 
   lemma(alpha_beta:types),
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v)) by 
   lemma(alpha_beta:types),
  all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos_list(?l) => succeeds val(?v),
  succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) => 
   succeeds val(?v),
  succeeds val(?v)],
 succeeds val(?v))
).

/** Termination of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT>,
<TT>beta_list/5</TT>. */

/** For recursiv defined functions in the prolog code there is only one
possibility to prove termination without splitting the prove in uncountable
lemmas. Namely prove it by induction over first the natural n and make
during the proof some inductions over the length of the position list. */

/** Induction I(n) for n natural. Notice that in contrast to 
<TT>min_max/3</TT> the only thing that has changed are the bounds 
a (alpha) and b (beta), */

:- lemma(alpha_beta:termination,
all n: succeeds nat(?n) =>
 (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
    terminates alpha_beta(?a,?b,?p,?n,?v)) &
  (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) & 
    succeeds val(?b) =>
     terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v)),
induction(
 [all n: succeeds nat(?n) => 
    (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       terminates alpha_beta(?a,?b,?p,?n,?v)) &
    (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
       terminates beta_list(?a,?b,?l,?n,?v))],
 /** n = 0 is simple, cause there is only one clause for that case. */
 [step([],
   [],
   [assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
     terminates alpha_beta(?a,?b,?p,0,?v) by 
      axiom(static_value:termination),
     terminates alpha_beta(?a,?b,?p,0,?v)),
    all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
      terminates alpha_beta(?a,?b,?p,0,?v),   
    /** Once again make an induction over the length of the list l: I(l). */ 
    induction(
     [all l: succeeds pos_list(?l) => 
	(all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	   terminates alpha_list(?a,?b,?l,0,?v) &
	   terminates beta_list(?a,?b,?l,0,?v))],
     /** l = [] trivial! */
     [step([],
       [],
       assume(succeeds val(?a) & succeeds val(?b),
	[terminates alpha_list(?a,?b,[],0,?v) by 
          axiom(value:leq:termination),
	 terminates beta_list(?a,?b,[],0,?v) by 
          axiom(value:leq:termination)],
	terminates alpha_list(?a,?b,[],0,?v) &
	terminates beta_list(?a,?b,[],0,?v)),
       all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	 terminates alpha_list(?a,?b,[],0,?v) &
	 terminates beta_list(?a,?b,[],0,?v)),
      /** this is the induction step I(l) to I([x|l]). */ 
      step([x,l],
       [all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	  terminates alpha_list(?a,?b,?l,0,?v) &
	  terminates beta_list(?a,?b,?l,0,?v),
	succeeds pos(?x),
	succeeds pos_list(?l)],
       assume(succeeds val(?a) & succeeds val(?b),
	[assume(?a = ?v,
          terminates ?b #=< ?a by axiom(value:leq:termination),
          terminates ?b #=< ?a),
	 terminates ?a #< ?b by lemma(value:less:termination),
	 assume(succeeds ?a #< ?b,
	  [assume(succeeds alpha_beta(?a,?b,?x,0,?v1),
            [succeeds val(?v1) by corollary(alpha_beta:types),
             terminates max(?a,?v1,?v2) by lemma(max:termination),
             assume(succeeds max(?a,?v1,?v2),
              [def succeeds max(?a,?v1,?v2) by completion,
	       cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
		[],
		fails ?a #=< ?v1 & ?v2 = ?a,
		[],
		succeeds val(?v2)),
	       all [v2,b,v]: succeeds val(?v2) & succeeds val(?b) => 
                 terminates alpha_list(?v2,?b,?l,0,?v) &
                 terminates beta_list(?v2,?b,?l,0,?v),
               terminates alpha_list(?v2,?b,?l,0,?v) &
                 terminates beta_list(?v2,?b,?l,0,?v),
               terminates alpha_list(?v2,?b,?l,0,?v)],
              terminates alpha_list(?v2,?b,?l,0,?v)),
             terminates (max(?a,?v1,?v2) & alpha_list(?v2,?b,?l,0,?v))],
            terminates (max(?a,?v1,?v2) & alpha_list(?v2,?b,?l,0,?v))),
           terminates 
           (alpha_beta(?a,?b,?x,0,?v1) & max(?a,?v1,?v2) &
            alpha_list(?v2,?b,?l,0,?v))],
	  terminates 
	  (alpha_beta(?a,?b,?x,0,?v1) & max(?a,?v1,?v2) &
	   alpha_list(?v2,?b,?l,0,?v))),
	 terminates 
	 (?a #< ?b & alpha_beta(?a,?b,?x,0,?v1) & max(?a,?v1,?v2) &
	  alpha_list(?v2,?b,?l,0,?v)),
	 (?a = ?v => terminates ?b #=< ?a) &
	 (all [v1,v2]: 
	   terminates 
	   (?a #< ?b & alpha_beta(?a,?b,?x,0,?v1) & max(?a,?v1,?v2) &
	    alpha_list(?v2,?b,?l,0,?v))),
	 terminates alpha_list(?a,?b,[?x|?l],0,?v),
         assume(?b = ?v,
           terminates ?b #=< ?a by axiom(value:leq:termination),
          terminates ?b #=< ?a),
	 assume(succeeds ?a #< ?b,
	  [assume(succeeds alpha_beta(?a,?b,?x,0,?v1),
            [succeeds val(?v1) by corollary(alpha_beta:types),
             terminates min(?b,?v1,?v2) by lemma(min:termination),
             assume(succeeds min(?b,?v1,?v2),
              [def succeeds min(?b,?v1,?v2) by completion,
	       cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
		[],
		fails ?b #=< ?v1 & ?v2 = ?v1,
		[],
		succeeds val(?v2)),
	       all [a,v2,v]: succeeds val(?a) & succeeds val(?v2) => 
                 terminates alpha_list(?a,?v2,?l,0,?v) &
                 terminates beta_list(?a,?v2,?l,0,?v),
                terminates alpha_list(?a,?v2,?l,0,?v) &
                 terminates beta_list(?a,?v2,?l,0,?v),
               terminates beta_list(?a,?v2,?l,0,?v)],
              terminates beta_list(?a,?v2,?l,0,?v)),
             terminates (min(?b,?v1,?v2) & beta_list(?a,?v2,?l,0,?v))],
            terminates (min(?b,?v1,?v2) & beta_list(?a,?v2,?l,0,?v))),
           terminates 
           (alpha_beta(?a,?b,?x,0,?v1) & min(?b,?v1,?v2) &
            beta_list(?a,?v2,?l,0,?v))],
	  terminates 
	  (alpha_beta(?a,?b,?x,0,?v1) & min(?b,?v1,?v2) &
	   beta_list(?a,?v2,?l,0,?v))),
	 terminates 
	 (?a #< ?b & alpha_beta(?a,?b,?x,0,?v1) & min(?b,?v1,?v2) &
	  beta_list(?a,?v2,?l,0,?v)),
	 (?b = ?v => terminates ?b #=< ?a) &
	 (all [v1,v2]: 
	   terminates 
	   (?a #< ?b & alpha_beta(?a,?b,?x,0,?v1) & min(?b,?v1,?v2) &
	    beta_list(?a,?v2,?l,0,?v))),
	 terminates beta_list(?a,?b,[?x|?l],0,?v) by completion],
	terminates alpha_list(?a,?b,[?x|?l],0,?v) &
	terminates beta_list(?a,?b,[?x|?l],0,?v)),
       all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	 terminates alpha_list(?a,?b,[?x|?l],0,?v) &
	 terminates beta_list(?a,?b,[?x|?l],0,?v))]),
    assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
     [all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	terminates alpha_list(?a,?b,?l,0,?v) &
	terminates beta_list(?a,?b,?l,0,?v),
      succeeds val(?a) & succeeds val(?b) => 
       terminates alpha_list(?a,?b,?l,0,?v) &
       terminates beta_list(?a,?b,?l,0,?v),
      terminates alpha_list(?a,?b,?l,0,?v) &
      terminates beta_list(?a,?b,?l,0,?v)],
     terminates alpha_list(?a,?b,?l,0,?v) &
     terminates beta_list(?a,?b,?l,0,?v))],
   (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
      terminates alpha_beta(?a,?b,?p,0,?v)) &
   (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
     succeeds val(?b) => terminates alpha_list(?a,?b,?l,0,?v) &
      terminates beta_list(?a,?b,?l,0,?v))),
  /** At that point of the proof I(0) is finisched. Now comes the
  induction step I(n) to I(n+1). */
  step([x],
   [(all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       terminates alpha_beta(?a,?b,?p,?x,?v)) &
    (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => terminates alpha_list(?a,?b,?l,?x,?v) &
       terminates beta_list(?a,?b,?l,?x,?v)),
    succeeds nat(?x)],
   [assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
     [terminates and_pos(?p) by axiom(and_pos:termination),
      assume(succeeds and_pos(?p),
       [terminates moves(?p,?l) by axiom(moves:termination),
        assume(succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
	  all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
           succeeds val(?b) => terminates alpha_list(?a,?b,?l,?x,?v) &
            terminates beta_list(?a,?b,?l,?x,?v),
           terminates alpha_list(?a,?b,?l,?x,?v) &
            terminates beta_list(?a,?b,?l,?x,?v),
          terminates beta_list(?a,?b,?l,?x,?v)],
         terminates beta_list(?a,?b,?l,?x,?v)),
        terminates (moves(?p,?l) & beta_list(?a,?b,?l,?x,?v))],
       terminates (moves(?p,?l) & beta_list(?a,?b,?l,?x,?v))),
      terminates (and_pos(?p) & moves(?p,?l) & beta_list(?a,?b,?l,?x,?v)),
      terminates or_pos(?p) by axiom(or_pos:termination),
      assume(succeeds or_pos(?p),
       [terminates moves(?p,?l) by axiom(moves:termination),
        assume(succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
	  all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
           succeeds val(?b) => terminates alpha_list(?a,?b,?l,?x,?v) &
            terminates beta_list(?a,?b,?l,?x,?v),
           terminates alpha_list(?a,?b,?l,?x,?v) &
            terminates beta_list(?a,?b,?l,?x,?v),
          terminates alpha_list(?a,?b,?l,?x,?v)],
         terminates alpha_list(?a,?b,?l,?x,?v)),
        terminates (moves(?p,?l) & alpha_list(?a,?b,?l,?x,?v))],
       terminates (moves(?p,?l) & alpha_list(?a,?b,?l,?x,?v))),
      terminates (or_pos(?p) & moves(?p,?l) & alpha_list(?a,?b,?l,?x,?v)),
      (all l: 
        terminates (and_pos(?p) & moves(?p,?l) & beta_list(?a,?b,?l,?x,?v))) &
      (all l: 
        terminates (or_pos(?p) & moves(?p,?l) & alpha_list(?a,?b,?l,?x,?v))),
      terminates alpha_beta(?a,?b,?p,s(?x),?v) by completion],
     terminates alpha_beta(?a,?b,?p,s(?x),?v)),
    all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
      terminates alpha_beta(?a,?b,?p,s(?x),?v),
    /** As we have proved the induction step for alpha_beta/5 we can 
    assume it as guaranteed, and begin the induction over the length 
    of the positionlist l for alpha_list/5 and beta_list/5. */
    induction(
     [all l: succeeds pos_list(?l) => 
	(all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	   terminates alpha_list(?a,?b,?l,s(?x),?v) &
	   terminates beta_list(?a,?b,?l,s(?x),?v))],
     /** l = []. */
     [step([],
       [],
       assume(succeeds val(?a) & succeeds val(?b),
	[terminates alpha_list(?a,?b,[],s(?x),?v) by 
          axiom(value:leq:termination),
	 terminates beta_list(?a,?b,[],s(?x),?v) by 
          axiom(value:leq:termination)],
	terminates alpha_list(?a,?b,[],s(?x),?v) &
	terminates beta_list(?a,?b,[],s(?x),?v)),
       all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	 terminates alpha_list(?a,?b,[],s(?x),?v) &
	 terminates beta_list(?a,?b,[],s(?x),?v)),
      /** Inductionstep I(l) to I([x|l]). */
      step([0,l],
       [all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	  terminates alpha_list(?a,?b,?l,s(?x),?v) &
	  terminates beta_list(?a,?b,?l,s(?x),?v),
	succeeds pos(?0),
	succeeds pos_list(?l)],
       assume(succeeds val(?a) & succeeds val(?b),
	[assume(?a = ?v,
          terminates ?b #=< ?a by axiom(value:leq:termination),
          terminates ?b #=< ?a),
	 terminates ?a #< ?b by lemma(value:less:termination),
	 assume(succeeds ?a #< ?b,
	  [assume(succeeds alpha_beta(?a,?b,?0,s(?x),?v1),
            [succeeds val(?v1) by corollary(alpha_beta:types),
             terminates max(?a,?v1,?v2) by lemma(max:termination),
             assume(succeeds max(?a,?v1,?v2),
              [def succeeds max(?a,?v1,?v2) by completion,
	       cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
		[],
		fails ?a #=< ?v1 & ?v2 = ?a,
		[],
		succeeds val(?v2)),
	       all [v2,b,v]: succeeds val(?v2) & succeeds val(?b) => 
                 terminates alpha_list(?v2,?b,?l,s(?x),?v) &
                 terminates beta_list(?v2,?b,?l,s(?x),?v),
                terminates alpha_list(?v2,?b,?l,s(?x),?v) &
                 terminates beta_list(?v2,?b,?l,s(?x),?v),
               terminates alpha_list(?v2,?b,?l,s(?x),?v)],
              terminates alpha_list(?v2,?b,?l,s(?x),?v)),
             terminates (max(?a,?v1,?v2) & alpha_list(?v2,?b,?l,s(?x),?v))],
            terminates (max(?a,?v1,?v2) & alpha_list(?v2,?b,?l,s(?x),?v))),
           terminates 
           (alpha_beta(?a,?b,?0,s(?x),?v1) & max(?a,?v1,?v2) &
            alpha_list(?v2,?b,?l,s(?x),?v))],
	  terminates 
	  (alpha_beta(?a,?b,?0,s(?x),?v1) & max(?a,?v1,?v2) &
	   alpha_list(?v2,?b,?l,s(?x),?v))),
	 terminates 
	 (?a #< ?b & alpha_beta(?a,?b,?0,s(?x),?v1) & max(?a,?v1,?v2) &
	  alpha_list(?v2,?b,?l,s(?x),?v)),
	 (?a = ?v => terminates ?b #=< ?a) &
	 (all [v1,v2]: 
	   terminates 
	   (?a #< ?b & alpha_beta(?a,?b,?0,s(?x),?v1) & max(?a,?v1,?v2) &
	    alpha_list(?v2,?b,?l,s(?x),?v))),
	 terminates alpha_list(?a,?b,[?0|?l],s(?x),?v) by completion,
	 assume(?b = ?v,
          terminates ?b #=< ?a by axiom(value:leq:termination),
          terminates ?b #=< ?a),
	 assume(succeeds ?a #< ?b,
	  [assume(succeeds alpha_beta(?a,?b,?0,s(?x),?v1),
            [succeeds val(?v1) by corollary(alpha_beta:types),
             terminates min(?b,?v1,?v2) by lemma(min:termination),
             assume(succeeds min(?b,?v1,?v2),
              [def succeeds min(?b,?v1,?v2) by completion,
	       cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
		[],
		fails ?b #=< ?v1 & ?v2 = ?v1,
		[],
		succeeds val(?v2)),
	       all [a,v2,v]: succeeds val(?a) & succeeds val(?v2) => 
                 terminates alpha_list(?a,?v2,?l,s(?x),?v) &
                 terminates beta_list(?a,?v2,?l,s(?x),?v),
               terminates alpha_list(?a,?v2,?l,s(?x),?v) &
                 terminates beta_list(?a,?v2,?l,s(?x),?v),
               terminates beta_list(?a,?v2,?l,s(?x),?v)],
              terminates beta_list(?a,?v2,?l,s(?x),?v)),
             terminates (min(?b,?v1,?v2) & beta_list(?a,?v2,?l,s(?x),?v))],
            terminates (min(?b,?v1,?v2) & beta_list(?a,?v2,?l,s(?x),?v))),
           terminates 
           (alpha_beta(?a,?b,?0,s(?x),?v1) & min(?b,?v1,?v2) &
            beta_list(?a,?v2,?l,s(?x),?v))],
	  terminates 
	  (alpha_beta(?a,?b,?0,s(?x),?v1) & min(?b,?v1,?v2) &
	   beta_list(?a,?v2,?l,s(?x),?v))),
	 terminates 
	 (?a #< ?b & alpha_beta(?a,?b,?0,s(?x),?v1) & min(?b,?v1,?v2) &
	  beta_list(?a,?v2,?l,s(?x),?v)),
	 (?b = ?v => terminates ?b #=< ?a) &
	 (all [v1,v2]: 
	   terminates 
	   (?a #< ?b & alpha_beta(?a,?b,?0,s(?x),?v1) & min(?b,?v1,?v2) &
	    beta_list(?a,?v2,?l,s(?x),?v))),
	 terminates beta_list(?a,?b,[?0|?l],s(?x),?v) by completion],
	terminates alpha_list(?a,?b,[?0|?l],s(?x),?v) &
	terminates beta_list(?a,?b,[?0|?l],s(?x),?v)),
       all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	 terminates alpha_list(?a,?b,[?0|?l],s(?x),?v) &
	 terminates beta_list(?a,?b,[?0|?l],s(?x),?v))]),
    assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
     [all [a,b,v]: succeeds val(?a) & succeeds val(?b) => 
	terminates alpha_list(?a,?b,?l,s(?x),?v) &
	terminates beta_list(?a,?b,?l,s(?x),?v),
      succeeds val(?a) & succeeds val(?b) => 
       terminates alpha_list(?a,?b,?l,s(?x),?v) &
       terminates beta_list(?a,?b,?l,s(?x),?v),
      terminates alpha_list(?a,?b,?l,s(?x),?v) &
      terminates beta_list(?a,?b,?l,s(?x),?v)],
     terminates alpha_list(?a,?b,?l,s(?x),?v) &
     terminates beta_list(?a,?b,?l,s(?x),?v))],
   (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
      terminates alpha_beta(?a,?b,?p,s(?x),?v)) &
   (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
     succeeds val(?b) => terminates alpha_list(?a,?b,?l,s(?x),?v) &
      terminates beta_list(?a,?b,?l,s(?x),?v)))])
).

/** The main <TT>lemma(alpha_beta:termination)</TT> tells us that 
<TT>alpha_beta/5</TT> really terminates, but for <TT>LPTP</TT> we 
have to guarantee termination independantly from <TT>alpha_list/5</TT> 
and <TT>beta_list/5</TT>. */ 

:- corollary(alpha_beta:termination,
all [a,b,p,n,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) => terminates alpha_beta(?a,?b,?p,?n,?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       terminates alpha_beta(?a,?b,?p,?n,?v)) &
    (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
       terminates beta_list(?a,?b,?l,?n,?v)) by 
   lemma(alpha_beta:termination),
  (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     terminates alpha_beta(?a,?b,?p,?n,?v)) &
  (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
    succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v)),
  all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     terminates alpha_beta(?a,?b,?p,?n,?v),
  terminates alpha_beta(?a,?b,?p,?n,?v)],
 terminates alpha_beta(?a,?b,?p,?n,?v))
).

/** Same remark for <TT>alpha_list/5</TT>. */

:- corollary(alpha_list:termination,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  terminates alpha_list(?a,?b,?l,?n,?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       terminates alpha_beta(?a,?b,?p,?n,?v)) &
    (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
       terminates beta_list(?a,?b,?l,?n,?v)) by 
   lemma(alpha_beta:termination),
  (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     terminates alpha_beta(?a,?b,?p,?n,?v)) &
  (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
    succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v)),
  all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
    succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v),
  terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v),
  terminates alpha_list(?a,?b,?l,?n,?v)],
 terminates alpha_list(?a,?b,?l,?n,?v))
).

/** For symmetry also for <TT>beta_list/5</TT>. */

:- corollary(beta_list:termination,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  terminates beta_list(?a,?b,?l,?n,?v),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       terminates alpha_beta(?a,?b,?p,?n,?v)) &
    (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
       terminates beta_list(?a,?b,?l,?n,?v)) by 
   lemma(alpha_beta:termination),
  (all [a,b,p,v]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     terminates alpha_beta(?a,?b,?p,?n,?v)) &
  (all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
    succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v)),
  all [a,b,l,v]: succeeds pos_list(?l) & succeeds val(?a) &
    succeeds val(?b) => terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v),
  terminates alpha_list(?a,?b,?l,?n,?v) &
     terminates beta_list(?a,?b,?l,?n,?v),
  terminates beta_list(?a,?b,?l,?n,?v)],
 terminates beta_list(?a,?b,?l,?n,?v))
).

/** Existence of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT>,
<TT>beta_list/5</TT>. */

/** Proving the code for <TT>alpha_beta/5</TT> is correct, we have to prove
the existence of a return value. */

/** For any given natural n and for any given bounds a and b, if
<TT>alpha_beta/5</TT> is called from a position p then there exists a value v 
<TT>alpha_beta/5</TT> is able to calculate. Analog if l is a position list
<TT>alpha_list/5</TT> and <TT>beta_list/5</TT> do find a value v 
(type is already guaranteed by <TT>lemma(alpha_beta:types)</TT>). */

:- lemma(alpha_beta:existence,
all n: succeeds nat(?n) =>
  (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
  (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,?n,?v))),
induction(
 [all n: succeeds nat(?n) => 
    (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
    (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,?n,?v)))],
 /** Induction I(n) with n natural. We begin with n = 0. */
 [step([],
   [],
   [assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
     [ex v: succeeds static_value(?p,?v) by 
       axiom(static_value:existence),
      exist(v,
       succeeds static_value(?p,?v),
       [succeeds alpha_beta(?a,?b,?p,0,?v),
	ex v: succeeds alpha_beta(?a,?b,?p,0,?v)],
       ex v: succeeds alpha_beta(?a,?b,?p,0,?v))],
     ex v: succeeds alpha_beta(?a,?b,?p,0,?v)), 
    all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
      (ex v: succeeds alpha_beta(?a,?b,?p,0,?v)),
    /** Second level of induction I(l) with l postition list. */
    induction(
     [all l: succeeds pos_list(?l) => 
	(all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	   (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
	   (ex v: succeeds beta_list(?a,?b,?l,0,?v)))],
     /** l = []. */
     [step([],
       [],
       assume(succeeds val(?a) & succeeds val(?b),
	[succeeds alpha_list(?a,?b,[],0,?a),
         ex v: succeeds alpha_list(?a,?b,[],0,?v),
	 succeeds beta_list(?a,?b,[],0,?b),
         ex v: succeeds beta_list(?a,?b,[],0,?v)],
	(ex v: succeeds alpha_list(?a,?b,[],0,?v)) &
	(ex v: succeeds beta_list(?a,?b,[],0,?v))),
       all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	 (ex v: succeeds alpha_list(?a,?b,[],0,?v)) &
	 (ex v: succeeds beta_list(?a,?b,[],0,?v))),
      /** Inductionstep on level two I(l) to I([x|l]). */
      step([x,l],
       [all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	  (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
	  (ex v: succeeds beta_list(?a,?b,?l,0,?v)),
	succeeds pos(?x),
	succeeds pos_list(?l)],
       assume(succeeds val(?a) & succeeds val(?b),
	[succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
         /** As we have those possible relations between values, we can
         make this case splitting, which is a one to one projection
         on the code. */
         cases(succeeds ?a #< ?b,
          [succeeds val(?a) & succeeds val(?b) &
            succeeds pos(?x) => (ex v: succeeds alpha_beta(?a,?b,?x,0,?v)),
	   ex v: succeeds alpha_beta(?a,?b,?x,0,?v),
           exist(v,
            succeeds alpha_beta(?a,?b,?x,0,?v),
            [succeeds val(?v) by corollary(alpha_beta:types),
             ex u: succeeds max(?a,?v,?u) by lemma(max:existence),
	     exist(u,
              succeeds max(?a,?v,?u),
              [def succeeds max(?a,?v,?u) by completion,
	       cases(succeeds ?a #=< ?v & ?u = ?v,
		[],
		fails ?a #=< ?v & ?u = ?a,
		[],
		succeeds val(?u)),
               succeeds pos_list(?l),
	       all [u,b]: succeeds val(?u) & succeeds val(?b) => 
                 (ex v: succeeds alpha_list(?u,?b,?l,0,?v)) &
                 (ex v: succeeds beta_list(?u,?b,?l,0,?v)),
               (ex v: succeeds alpha_list(?u,?b,?l,0,?v)) &
               (ex v: succeeds beta_list(?u,?b,?l,0,?v)),
               ex v: succeeds alpha_list(?u,?b,?l,0,?v),
               exist(0,
                succeeds alpha_list(?u,?b,?l,0,?0),
                [succeeds val(?0) by corollary(alpha_list:types),
		 succeeds alpha_list(?a,?b,[?x|?l],0,?0),
                 ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v)],
                ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v))],
              ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v))],
            ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v))],
          succeeds ?b #=< ?a,
          [succeeds alpha_list(?a,?b,[?x|?l],0,?a),
	   ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v)],
          ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v)),
	 cases(succeeds ?a #< ?b,
          [succeeds val(?a) & succeeds val(?b) &
            succeeds pos(?x) => (ex v: succeeds alpha_beta(?a,?b,?x,0,?v)),
	    ex v: succeeds alpha_beta(?a,?b,?x,0,?v),
           exist(v,
            succeeds alpha_beta(?a,?b,?x,0,?v),
            [succeeds val(?v) by corollary(alpha_beta:types),
	     ex u: succeeds min(?b,?v,?u) by lemma(min:existence),
             exist(u,
              succeeds min(?b,?v,?u),
              [def succeeds min(?b,?v,?u) by completion,
	       cases(succeeds ?b #=< ?v & ?u = ?b,
		[],
		fails ?b #=< ?v & ?u = ?v,
		[],
		succeeds val(?u)),
	       all [a,u]: succeeds val(?a) & succeeds val(?u) => 
                 (ex v: succeeds alpha_list(?a,?u,?l,0,?v)) &
                 (ex v: succeeds beta_list(?a,?u,?l,0,?v)),
               (ex v: succeeds alpha_list(?a,?u,?l,0,?v)) &
               (ex v: succeeds beta_list(?a,?u,?l,0,?v)),
               ex v: succeeds beta_list(?a,?u,?l,0,?v),
               exist(0,
                succeeds beta_list(?a,?u,?l,0,?0),
                [succeeds val(?0) by corollary(beta_list:types),
		 succeeds beta_list(?a,?b,[?x|?l],0,?0),
                 ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v)],
                ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v))],
              ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v))],
            ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v))],
          succeeds ?b #=< ?a,
          [succeeds beta_list(?a,?b,[?x|?l],0,?b),
	   ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v)],
          ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v))],
	(ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v)) &
	(ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v))),
       all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	 (ex v: succeeds alpha_list(?a,?b,[?x|?l],0,?v)) &
	 (ex v: succeeds beta_list(?a,?b,[?x|?l],0,?v)))]),
    assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
     [all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	(ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
	(ex v: succeeds beta_list(?a,?b,?l,0,?v)),
      succeeds val(?a) & succeeds val(?b) => 
       (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,0,?v)),
      (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
      (ex v: succeeds beta_list(?a,?b,?l,0,?v))],
     (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,0,?v)))],
   (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
      (ex v: succeeds alpha_beta(?a,?b,?p,0,?v))) &
   (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & 
     succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,0,?v)) &
      (ex v: succeeds beta_list(?a,?b,?l,0,?v)))),
  /** I(0) is for alpha_beta/5, alpha_list/5 and beta_list/5 proven.
  Now comes the inductionstep I(n) to I(n+1). */
  step([x],
   [(all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       (ex v: succeeds alpha_beta(?a,?b,?p,?x,?v))) &
    (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?x,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,?x,?v))),
    succeeds nat(?x)],
   [assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
     [succeeds and_pos(?p) \/ succeeds or_pos(?p) by axiom(pos:total),
      cases(succeeds and_pos(?p),
       [ex l: succeeds moves(?p,?l) by axiom(moves:existence),
	exist(l,
         succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
          all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
           succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?x,?v)) &
            (ex v: succeeds beta_list(?a,?b,?l,?x,?v)),
	  (ex v: succeeds alpha_list(?a,?b,?l,?x,?v)) &
          (ex v: succeeds beta_list(?a,?b,?l,?x,?v)),
          ex v: succeeds beta_list(?a,?b,?l,?x,?v),
          exist(v,
           succeeds beta_list(?a,?b,?l,?x,?v),
           [succeeds alpha_beta(?a,?b,?p,s(?x),?v),
	    ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v)],
           ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))],
         ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))],
       succeeds or_pos(?p),
       [ex l: succeeds moves(?p,?l) by axiom(moves:existence),
	exist(l,
         succeeds moves(?p,?l),
         [succeeds pos_list(?l) by axiom(moves:list:types),
          all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
           succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?x,?v)) &
            (ex v: succeeds beta_list(?a,?b,?l,?x,?v)),
          (ex v: succeeds alpha_list(?a,?b,?l,?x,?v)) &
          (ex v: succeeds beta_list(?a,?b,?l,?x,?v)),
          ex v: succeeds alpha_list(?a,?b,?l,?x,?v),
	  exist(v,
           succeeds alpha_list(?a,?b,?l,?x,?v),
           [succeeds alpha_beta(?a,?b,?p,s(?x),?v),
	    ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v)],
           ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))],
         ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))],
       ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))],
     ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v)),
    all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
      (ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v)),
    /** For alpha_beta/5 I(n) to I(n+1) was no problem. For alpha_list/5
    and beta_list/5 there is no other way then induction over the
    length of the positionlist. */
    induction(
     [all l: succeeds pos_list(?l) => 
	(all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	   (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
	   (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v)))],
     /** l = []. */
     [step([],
       [],
       assume(succeeds val(?a) & succeeds val(?b),
	[succeeds alpha_list(?a,?b,[],s(?x),?a),
         ex v: succeeds alpha_list(?a,?b,[],s(?x),?v),
	 succeeds beta_list(?a,?b,[],s(?x),?b),
         ex v: succeeds beta_list(?a,?b,[],s(?x),?v)],
	(ex v: succeeds alpha_list(?a,?b,[],s(?x),?v)) &
	(ex v: succeeds beta_list(?a,?b,[],s(?x),?v))),
       all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	 (ex v: succeeds alpha_list(?a,?b,[],s(?x),?v)) &
	 (ex v: succeeds beta_list(?a,?b,[],s(?x),?v))),
      /** Inductionstep I(l) to I([x|l]). */
      step([0,l],
       [all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	  (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
	  (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v)),
	succeeds pos(?0),
	succeeds pos_list(?l)],
       assume(succeeds val(?a) & succeeds val(?b),
	[succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
         cases(succeeds ?a #< ?b,
          [all [a,b,0]: succeeds val(?a) & succeeds val(?b) &
            succeeds pos(?0) => 
             (ex v: succeeds alpha_beta(?a,?b,?0,s(?x),?v)),
	   ex v: succeeds alpha_beta(?a,?b,?0,s(?x),?v),
           exist(v,
            succeeds alpha_beta(?a,?b,?0,s(?x),?v),
            [succeeds val(?v) by corollary(alpha_beta:types),
	     ex u: succeeds max(?a,?v,?u) by lemma(max:existence),
             exist(u,
              succeeds max(?a,?v,?u),
              [def succeeds max(?a,?v,?u) by completion,
	       cases(succeeds ?a #=< ?v & ?u = ?v,
		[],
		fails ?a #=< ?v & ?u = ?a,
		[],
		succeeds val(?u)),
	       all [u,b]: succeeds val(?u) & succeeds val(?b) => 
                 (ex v: succeeds alpha_list(?u,?b,?l,s(?x),?v)) &
                 (ex v: succeeds beta_list(?u,?b,?l,s(?x),?v)),
               (ex v: succeeds alpha_list(?u,?b,?l,s(?x),?v)) &
               (ex v: succeeds beta_list(?u,?b,?l,s(?x),?v)),
               ex v: succeeds alpha_list(?u,?b,?l,s(?x),?v),
               exist(1,
                succeeds alpha_list(?u,?b,?l,s(?x),?1),
                [succeeds val(?1) by corollary(alpha_list:types),
		 succeeds alpha_list(?a,?b,[?0|?l],s(?x),?1),
                 ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v)],
                ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v))],
              ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v))],
            ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v))],
          succeeds ?b #=< ?a,
          [succeeds alpha_list(?a,?b,[?0|?l],s(?x),?a),
	   ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v)],
          ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v)),
	 cases(succeeds ?a #< ?b,
          [all [a,b,0]: succeeds val(?a) & succeeds val(?b) &
            succeeds pos(?0) => 
             (ex v: succeeds alpha_beta(?a,?b,?0,s(?x),?v)),
	   ex v: succeeds alpha_beta(?a,?b,?0,s(?x),?v),
	   exist(v,
            succeeds alpha_beta(?a,?b,?0,s(?x),?v),
            [succeeds val(?v) by corollary(alpha_beta:types),
             ex u: succeeds min(?b,?v,?u) by lemma(min:existence),
	     exist(u,
              succeeds min(?b,?v,?u),
              [def succeeds min(?b,?v,?u) by completion,
	       cases(succeeds ?b #=< ?v & ?u = ?b,
		[],
		fails ?b #=< ?v & ?u = ?v,
		[],
		succeeds val(?u)),
	       all [a,u]: succeeds val(?a) & succeeds val(?u) => 
                 (ex v: succeeds alpha_list(?a,?u,?l,s(?x),?v)) &
                 (ex v: succeeds beta_list(?a,?u,?l,s(?x),?v)),
               (ex v: succeeds alpha_list(?a,?u,?l,s(?x),?v)) &
               (ex v: succeeds beta_list(?a,?u,?l,s(?x),?v)),
               ex v: succeeds beta_list(?a,?u,?l,s(?x),?v),
               exist(1,
                succeeds beta_list(?a,?u,?l,s(?x),?1),
                [succeeds val(?1) by corollary(beta_list:types),
		 succeeds beta_list(?a,?b,[?0|?l],s(?x),?1),
                 ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v)],
                ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v))],
              ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v))],
            ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v))],
          succeeds ?b #=< ?a,
          [succeeds beta_list(?a,?b,[?0|?l],s(?x),?b),
	   ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v)],
          ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v))],
	(ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v)) &
	(ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v))),
       all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	 (ex v: succeeds alpha_list(?a,?b,[?0|?l],s(?x),?v)) &
	 (ex v: succeeds beta_list(?a,?b,[?0|?l],s(?x),?v)))]),
    assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
     [all [a,b]: succeeds val(?a) & succeeds val(?b) => 
	(ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
	(ex v: succeeds beta_list(?a,?b,?l,s(?x),?v)),
      succeeds val(?a) & succeeds val(?b) => 
       (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v)),
      (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
      (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v))],
     (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v)))],
   (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
      (ex v: succeeds alpha_beta(?a,?b,?p,s(?x),?v))) &
   (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & 
     succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,s(?x),?v)) &
      (ex v: succeeds beta_list(?a,?b,?l,s(?x),?v))))])
).

/** Now comes the assurement for the independant existence for
<TT>alpha_beta/5</TT>. */

:- corollary(alpha_beta:existence,
all [a,b,p,n]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) =>
  (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v)),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
    (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,?n,?v))) by 
   lemma(alpha_beta:existence),
  (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
  (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,?n,?v))),
  all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v)),
  ex v: succeeds alpha_beta(?a,?b,?p,?n,?v)],
 ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))
).

/** Same for <TT>alpha_list/5</TT>. */

:- corollary(alpha_list:existence,
all [a,b,l,n]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
    (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,?n,?v))) by 
   lemma(alpha_beta:existence),
  (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
  (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,?n,?v))),
  all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
    (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
    (ex v: succeeds beta_list(?a,?b,?l,?n,?v)),
  (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
  (ex v: succeeds beta_list(?a,?b,?l,?n,?v)),
  ex v: succeeds alpha_list(?a,?b,?l,?n,?v)],
 ex v: succeeds alpha_list(?a,?b,?l,?n,?v))
).

/** And finally the existence for <TT>beta_list/5</TT>. */

:- corollary(beta_list:existence,
all [a,b,l,n]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  (ex v: succeeds beta_list(?a,?b,?l,?n,?v)),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n),
 [all n: succeeds nat(?n) => 
    (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
       (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
    (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) &
      succeeds val(?b) => (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
       (ex v: succeeds beta_list(?a,?b,?l,?n,?v))) by 
   lemma(alpha_beta:existence),
  (all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (ex v: succeeds alpha_beta(?a,?b,?p,?n,?v))) &
  (all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
     (ex v: succeeds beta_list(?a,?b,?l,?n,?v))),
  all [a,b,l]: succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
    (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
    (ex v: succeeds beta_list(?a,?b,?l,?n,?v)),
  (ex v: succeeds alpha_list(?a,?b,?l,?n,?v)) &
  (ex v: succeeds beta_list(?a,?b,?l,?n,?v)),
  ex v: succeeds beta_list(?a,?b,?l,?n,?v)],
 ex v: succeeds beta_list(?a,?b,?l,?n,?v))
).

/** Uniqueness of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT>,
<TT>beta_list/5</TT>. */

/** It may occur the question why we need uniqueness for an algorithm.
The response is simple. Because you need same result for same
parameter list you call the algorithm with. */ 

/** We prove uniqueness of <TT>alpha_beta/5</TT>, <TT>alpha_list/5</TT> 
and <TT>beta_list/5</TT> by induction over the length of list of 
parameters needed. *//** We prove uniqueness of <TT>alpha_beta/5</TT>, 
<TT>alpha_list/5</TT> and <TT>beta_list/5</TT> by induction over the 
length of list of parameters needed. */

:- lemma(alpha_beta:uniqueness,
(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) =>
   (succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
     (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1))) &
(all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) =>
   (succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1))) &
(all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) =>
   (succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) =>
     (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1))),
induction(
 [all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
    succeeds val(?b) & succeeds pos(?p) => 
     (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1),
  all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
    succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
     (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
  all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
    succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
     (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)],
 [step([0,1,p,v],
   [succeeds static_value(?p,?v)],
   assume(succeeds val(?0) & succeeds val(?1) & succeeds pos(?p),
    assume(succeeds alpha_beta(?0,?1,?p,0,?v1),
     [def succeeds alpha_beta(?0,?1,?p,0,?v1) by completion,
      succeeds static_value(?p,?v1),
      ?v = ?v1 by axiom(static_value:uniqueness)],
     ?v = ?v1),
    all v1: succeeds alpha_beta(?0,?1,?p,0,?v1) => ?v = ?v1),
   succeeds val(?0) & succeeds val(?1) & succeeds pos(?p) => 
    (all v1: succeeds alpha_beta(?0,?1,?p,0,?v1) => ?v = ?v1)),
  step([a,b,p,n,v,l],
   [succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
     (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
    succeeds and_pos(?p),
    succeeds moves(?p,?l),
    succeeds beta_list(?a,?b,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
    assume(succeeds alpha_beta(?a,?b,?p,s(?n),?v1),
     [def succeeds alpha_beta(?a,?b,?p,s(?n),?v1) by completion,
      cases(
       ex l: succeeds and_pos(?p) & succeeds moves(?p,?l) &
        succeeds beta_list(?a,?b,?l,?n,?v1),
       exist(0,
        succeeds and_pos(?p) & succeeds moves(?p,?0) &
        succeeds beta_list(?a,?b,?0,?n,?v1),
        [succeeds pos_list(?0) by axiom(moves:list:types),
	 ?0 = ?l by axiom(moves:uniqueness),
         succeeds beta_list(?a,?b,?l,?n,?v1),
         succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
          (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
         all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1, 
         ?v = ?v1],
        ?v = ?v1),
       ex l: succeeds or_pos(?p) & succeeds moves(?p,?l) &
        succeeds alpha_list(?a,?b,?l,?n,?v1),
       exist(0,
        succeeds or_pos(?p) & succeeds moves(?p,?0) &
        succeeds alpha_list(?a,?b,?0,?n,?v1),
        [succeeds and_pos(?p) & succeeds or_pos(?p),
         all p: succeeds pos(?p) => 
          ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by
           axiom(pos:disjoint),
	  ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by
           axiom(pos:disjoint),
	 ?v = ?v1],
        ?v = ?v1),
       ?v = ?v1)],
     ?v = ?v1),
    all v1: succeeds alpha_beta(?a,?b,?p,s(?n),?v1) => ?v = ?v1),
   succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
    (all v1: succeeds alpha_beta(?a,?b,?p,s(?n),?v1) => ?v = ?v1)),
  step([a,b,p,n,v,l],
   [succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
     (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
    succeeds or_pos(?p),
    succeeds moves(?p,?l),
    succeeds alpha_list(?a,?b,?l,?n,?v)],
   assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
    assume(succeeds alpha_beta(?a,?b,?p,s(?n),?v1),
     [def succeeds alpha_beta(?a,?b,?p,s(?n),?v1) by completion,
      cases(
       ex l: succeeds and_pos(?p) & succeeds moves(?p,?l) &
        succeeds beta_list(?a,?b,?l,?n,?v1),
       exist(0,
        succeeds and_pos(?p) & succeeds moves(?p,?0) &
        succeeds beta_list(?a,?b,?0,?n,?v1),
        [succeeds and_pos(?p) & succeeds or_pos(?p),
         all p: succeeds pos(?p) => 
          ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by
           axiom(pos:disjoint),
	 ~ (succeeds and_pos(?p) & succeeds or_pos(?p)) by
           axiom(pos:disjoint),
         ?v = ?v1],
        ?v = ?v1),
       ex l: succeeds or_pos(?p) & succeeds moves(?p,?l) &
        succeeds alpha_list(?a,?b,?l,?n,?v1),
       exist(0,
        succeeds or_pos(?p) & succeeds moves(?p,?0) &
        succeeds alpha_list(?a,?b,?0,?n,?v1),
        [succeeds pos_list(?0) by axiom(moves:list:types),
	 ?0 = ?l by axiom(moves:uniqueness),
         succeeds alpha_list(?a,?b,?l,?n,?v1),
         succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
          (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
         all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1,
         ?v = ?v1],
        ?v = ?v1),
       ?v = ?v1)],
     ?v = ?v1),
    all v1: succeeds alpha_beta(?a,?b,?p,s(?n),?v1) => ?v = ?v1),
   succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
    (all v1: succeeds alpha_beta(?a,?b,?p,s(?n),?v1) => ?v = ?v1)),
  step([a,b,l,0],
   [succeeds ?b #=< ?a \/ ?l = []],
   assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
    assume(succeeds alpha_list(?a,?b,?l,?0,?v1),
     [def succeeds alpha_list(?a,?b,?l,?0,?v1) by completion,
      cases(?v1 = ?a & (succeeds ?b #=< ?a \/ ?l = []),
       [],
       ex [p,3,4,v2]: ?l = [?p|?3] & succeeds ?a #< ?b &
        succeeds alpha_beta(?a,?b,?p,?0,?4) & succeeds max(?a,?4,?v2) &
        succeeds alpha_list(?v2,?b,?3,?0,?v1),
       exist([p,3,4,v2],
        ?l = [?p|?3] & succeeds ?a #< ?b &
        succeeds alpha_beta(?a,?b,?p,?0,?4) & succeeds max(?a,?4,?v2) &
        succeeds alpha_list(?v2,?b,?3,?0,?v1),
        [succeeds ?a #< ?b,
         fails ?b #=< ?a by lemma(value:leqless),
          ?l = [?p|?3],
	 succeeds ?b #=< ?a \/ ?l = [],
         cases(succeeds ?b #=< ?a,[],?l = [],[],?a = ?v1)],
        ?a = ?v1),
       ?a = ?v1)],
     ?a = ?v1),
    all v1: succeeds alpha_list(?a,?b,?l,?0,?v1) => ?a = ?v1),
   succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
    (all v1: succeeds alpha_list(?a,?b,?l,?0,?v1) => ?a = ?v1)),
  step([a,b,p,l,n,v,v1,v2],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (all 0: succeeds alpha_beta(?a,?b,?p,?n,?0) => ?v1 = ?0),
    succeeds pos_list(?l) & succeeds val(?v2) & succeeds val(?b) => 
     (all v1: succeeds alpha_list(?v2,?b,?l,?n,?v1) => ?v = ?v1),
    succeeds ?a #< ?b,
    succeeds alpha_beta(?a,?b,?p,?n,?v1),
    succeeds max(?a,?v1,?v2),
    succeeds alpha_list(?v2,?b,?l,?n,?v)],
   assume(succeeds pos_list([?p|?l]) & succeeds val(?a) & succeeds val(?b),
    [assume(succeeds alpha_list(?a,?b,[?p|?l],?n,?0),
      [def succeeds alpha_list(?a,?b,[?p|?l],?n,?0) by completion,
       cases(?a = ?0 & (succeeds ?b #=< ?a \/ [?p|?l] = []),
        cases(succeeds ?b #=< ?a,
          [def succeeds ?a #< ?b by completion,
           fails ?b #=< ?a by lemma(value:less:ref),
           ?v = ?0],
           [?p|?l] = [],[],?v = ?0),
        ex [v1,v2]: succeeds ?a #< ?b & 
         succeeds alpha_beta(?a,?b,?p,?n,?v1) & succeeds max(?a,?v1,?v2) &
         succeeds alpha_list(?v2,?b,?l,?n,?0),
        exist([1,2],
         succeeds ?a #< ?b & succeeds alpha_beta(?a,?b,?p,?n,?1) &
         succeeds max(?a,?1,?2) & succeeds alpha_list(?2,?b,?l,?n,?0),
         [def succeeds pos_list([?p|?l]) by completion,succeeds pos(?p),
          succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
           (all 1: succeeds alpha_beta(?a,?b,?p,?n,?1) => ?v1 = ?1), 
          all 1: succeeds alpha_beta(?a,?b,?p,?n,?1) => ?v1 = ?1,
          ?v1 = ?1,
          succeeds val(?v1) by corollary(alpha_beta:types),
          succeeds pos_list(?l),
          succeeds max(?a,?v1,?2),
          succeeds max(?a,?v1,?v2),
          def succeeds max(?a,?v1,?v2) by completion,
	  cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
	   [],
	   fails ?a #=< ?v1 & ?v2 = ?a,
	   [],
	   succeeds val(?v2)),
          def succeeds max(?a,?v1,?v2) by completion,
	  cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
	   [def succeeds max(?a,?v1,?2) by completion,
            cases(succeeds ?a #=< ?v1 & ?2 = ?v1,
             [],
             fails ?a #=< ?v1 & ?2 = ?a,
             [],
             ?v2 = ?2)],
	   fails ?a #=< ?v1 & ?v2 = ?a,
	   [def succeeds max(?a,?v1,?2) by completion,
            cases(succeeds ?a #=< ?v1 & ?2 = ?v1,
             [],
             fails ?a #=< ?v1 & ?2 = ?a,
             [],
             ?v2 = ?2)],
	   ?v2 = ?2),
          succeeds alpha_list(?v2,?b,?l,?n,?0),
          succeeds pos_list(?l),
          succeeds pos_list(?l) & succeeds val(?v2) & succeeds val(?b) => 
           (all v1: succeeds alpha_list(?v2,?b,?l,?n,?v1) => ?v = ?v1),    
          all v1: succeeds alpha_list(?v2,?b,?l,?n,?v1) => ?v = ?v1,
          ?v = ?0],
         ?v = ?0),
        ?v = ?0)],
      ?v = ?0),
     all 0: succeeds alpha_list(?a,?b,[?p|?l],?n,?0) => ?v = ?0],
    all v1: succeeds alpha_list(?a,?b,[?p|?l],?n,?v1) => ?v = ?v1),
   succeeds pos_list([?p|?l]) & succeeds val(?a) & succeeds val(?b) => 
    (all v1: succeeds alpha_list(?a,?b,[?p|?l],?n,?v1) => ?v = ?v1)),
  step([a,b,l,0],
   [succeeds ?b #=< ?a \/ ?l = []],
   assume(succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b),
    assume(succeeds beta_list(?a,?b,?l,?0,?v1),
     [def succeeds beta_list(?a,?b,?l,?0,?v1) by completion,
      cases(?v1 = ?b & (succeeds ?b #=< ?a \/ ?l = []),
       [],
       ex [p,3,4,v2]: ?l = [?p|?3] & succeeds ?a #< ?b &
        succeeds alpha_beta(?a,?b,?p,?0,?4) & succeeds min(?b,?4,?v2) &
        succeeds beta_list(?a,?v2,?3,?0,?v1),
       exist([p,3,4,v2],
        ?l = [?p|?3] & succeeds ?a #< ?b &
        succeeds alpha_beta(?a,?b,?p,?0,?4) & succeeds min(?b,?4,?v2) &
        succeeds beta_list(?a,?v2,?3,?0,?v1),
        [fails ?b #=< ?a by lemma(value:leqless),
	 ?l = [?p|?3],
         succeeds ?b #=< ?a \/ ?l = [],
         cases(succeeds ?b #=< ?a,[],?l = [],[],?b = ?v1)],
        ?b = ?v1),
       ?b = ?v1)],
     ?b = ?v1),
    all v1: succeeds beta_list(?a,?b,?l,?0,?v1) => ?b = ?v1),
   succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
    (all v1: succeeds beta_list(?a,?b,?l,?0,?v1) => ?b = ?v1)),
  step([a,b,p,l,n,v,v1,v2],
   [succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
     (all 0: succeeds alpha_beta(?a,?b,?p,?n,?0) => ?v1 = ?0),
    succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?v2) => 
     (all v1: succeeds beta_list(?a,?v2,?l,?n,?v1) => ?v = ?v1),
    succeeds ?a #< ?b,
    succeeds alpha_beta(?a,?b,?p,?n,?v1),
    succeeds min(?b,?v1,?v2),
    succeeds beta_list(?a,?v2,?l,?n,?v)],
   assume(succeeds pos_list([?p|?l]) & succeeds val(?a) & succeeds val(?b),
    [assume(succeeds beta_list(?a,?b,[?p|?l],?n,?0),
      [def succeeds beta_list(?a,?b,[?p|?l],?n,?0) by completion,
       cases(?b = ?0 & (succeeds ?b #=< ?a \/ [?p|?l] = []),
	 cases(succeeds ?b #=< ?a,
          [def succeeds ?a #< ?b by completion,
           fails ?b #=< ?a by lemma(value:less:ref),
           ?v = ?0],
          [?p|?l] = [],[],?v = ?0),
        ex [v1,v2]: succeeds ?a #< ?b & 
         succeeds alpha_beta(?a,?b,?p,?n,?v1) & succeeds min(?b,?v1,?v2) &
         succeeds beta_list(?a,?v2,?l,?n,?0),
        exist([1,2],
         succeeds ?a #< ?b & succeeds alpha_beta(?a,?b,?p,?n,?1) &
         succeeds min(?b,?1,?2) & succeeds beta_list(?a,?2,?l,?n,?0),
         [def succeeds pos_list([?p|?l]) by completion,succeeds pos(?p),
          succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) => 
           (all 1: succeeds alpha_beta(?a,?b,?p,?n,?1) => ?v1 = ?1),
          all 1: succeeds alpha_beta(?a,?b,?p,?n,?1) => ?v1 = ?1,
          ?v1 = ?1,
          succeeds val(?v1) by corollary(alpha_beta:types),
          succeeds min(?b,?v1,?2),
          succeeds min(?b,?v1,?v2),
          def succeeds min(?b,?v1,?v2) by completion,
	  cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
	   [def succeeds min(?b,?v1,?2) by completion,
            cases(succeeds ?b #=< ?v1 & ?2 = ?b,
             [],
             fails ?b #=< ?v1 & ?2 = ?v1,
             [],
             ?v2 = ?2)],
	   fails ?b #=< ?v1 & ?v2 = ?v1,
	   [def succeeds min(?b,?v1,?2) by completion,
            cases(succeeds ?b #=< ?v1 & ?2 = ?b,
             [],
             fails ?b #=< ?v1 & ?2 = ?v1,
             [],
             ?v2 = ?2)],
	   ?v2 = ?2),
          def succeeds min(?b,?v1,?v2) by completion,
	  cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
	   [],
	   fails ?b #=< ?v1 & ?v2 = ?v1,
	   [],
	   succeeds val(?v2)),
          succeeds beta_list(?a,?v2,?l,?n,?0),
          succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?v2) => 
           (all v1: succeeds beta_list(?a,?v2,?l,?n,?v1) => ?v = ?v1),
          all v1: succeeds beta_list(?a,?v2,?l,?n,?v1) => ?v = ?v1,
          ?v = ?0],
         ?v = ?0),
        ?v = ?0)],
      ?v = ?0),
     all 0: succeeds beta_list(?a,?b,[?p|?l],?n,?0) => ?v = ?0],
    all v1: succeeds beta_list(?a,?b,[?p|?l],?n,?v1) => ?v = ?v1),
   succeeds pos_list([?p|?l]) & succeeds val(?a) & succeeds val(?b) => 
    (all v1: succeeds beta_list(?a,?b,[?p|?l],?n,?v1) => ?v = ?v1))])
).

/** Now we have the proof of uniqueness, so we can prove it for 
<TT>alpha_beta/5</TT> itself without <TT>alpha_list/5</TT> and 
<TT>beta_list/5</TT>. */

:- corollary(alpha_beta:uniqueness,
all [a,b,p,n,v,v1]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos(?p) & succeeds alpha_beta(?a,?b,?p,?n,?v) &
 succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1,
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds alpha_beta(?a,?b,?p,?n,?v) & succeeds alpha_beta(?a,?b,?p,?n,?v1),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => 
      (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) by 
   lemma(alpha_beta:uniqueness),
  all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => 
      (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1),
  succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => 
      (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1),
  all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** The uniqueness of <TT>alpha_list/5</TT> is sometimes independant from
<TT>alpha_beta/5</TT> and <TT>beta_list/5</TT> needed. */

:- corollary(alpha_list:uniqueness,
all [a,b,l,n,v,v1]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds alpha_list(?a,?b,?l,?n,?v) &
 succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1,
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds alpha_list(?a,?b,?l,?n,?v) & succeeds alpha_list(?a,?b,?l,?n,?v1),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => 
      (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) by 
   lemma(alpha_beta:uniqueness),
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)),
  all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
  succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
  all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** So also  the return value of <TT>beta_list/5</TT> is unique. */ 

:- corollary(beta_list:uniqueness,
all [a,b,l,n,v,v1]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds beta_list(?a,?b,?l,?n,?v) &
 succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1,
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds beta_list(?a,?b,?l,?n,?v) & succeeds beta_list(?a,?b,?l,?n,?v1),
 [(all [a,b,p,n,v]: succeeds alpha_beta(?a,?b,?p,?n,?v) => succeeds val(?a) &
     succeeds val(?b) & succeeds pos(?p) => 
      (all v1: succeeds alpha_beta(?a,?b,?p,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) by 
   lemma(alpha_beta:uniqueness),
  (all [a,b,l,n,v]: succeeds alpha_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds alpha_list(?a,?b,?l,?n,?v1) => ?v = ?v1)) &
  (all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1)),
  all [a,b,l,n,v]: succeeds beta_list(?a,?b,?l,?n,?v) => 
     succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
  succeeds pos_list(?l) & succeeds val(?a) & succeeds val(?b) => 
      (all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1),
  all v1: succeeds beta_list(?a,?b,?l,?n,?v1) => ?v = ?v1,
  ?v = ?v1],
 ?v = ?v1)
).

/** We can introduce function symbols for <TT>alpha_beta/5</TT>, 
<TT>alpha_list/5</TT>, <TT>beta_list/5</TT>. */

/** <TT>ab/4</TT> is the definition symbol for <TT>alpha_beta/5</TT>. */

:- definition_fun(ab,4,
all [a,b,p,n,v]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos(?p) & succeeds nat(?n) =>
  (ab(?a,?b,?p,?n) = ?v <=> succeeds alpha_beta(?a,?b,?p,?n,?v)),
existence by corollary(alpha_beta:existence),
uniqueness by corollary(alpha_beta:uniqueness)
).

/** <TT>al/4</TT> is the function symbol for <TT>alpha_list/5</TT>. */

:- definition_fun(al,4,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  (al(?a,?b,?l,?n) = ?v <=> succeeds alpha_list(?a,?b,?l,?n,?v)),
existence by corollary(alpha_list:existence),
uniqueness by corollary(alpha_list:uniqueness)
).

/** <TT>bl/4</TT> is the function symbol for <TT>beta_list/5</TT>. */

:- definition_fun(bl,4,
all [a,b,l,n,v]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) =>
  (bl(?a,?b,?l,?n) = ?v <=> succeeds beta_list(?a,?b,?l,?n,?v)),
existence by corollary(beta_list:existence),
uniqueness by corollary(beta_list:uniqueness)
).

/** Properties of the functions <TT>ab/4</TT>, <TT>al/4</TT> and 
<TT>bl/4</TT>. 
Notice that a = alpha = lower bound and b = beta = higher bound. */

/** If the natural n = 0 then <TT>ab/4 = sv/1</TT>. */

:- lemma(ab:zero,
all [a,b,p]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) =>
  ab(?a,?b,?p,0) = sv(?p),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p),
 [succeeds static_value(?p,sv(?p)) by existence(sv,1),
  succeeds alpha_beta(?a,?b,?p,0,sv(?p)) by completion,
  ab(?a,?b,?p,0) = sv(?p) by uniqueness(ab,4)],
 ab(?a,?b,?p,0) = sv(?p))
).

/** If the position p is a AND node, then <TT>ab/4 = bl/4</TT>. */

:- lemma(ab:and_pos,
all [a,b,p,n]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) & succeeds and_pos(?p) =>
  ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) & succeeds and_pos(?p),
 [succeeds pos_list(ms(?p)) by lemma(ms:types),
  succeeds beta_list(?a,?b,ms(?p),?n,bl(?a,?b,ms(?p),?n)) by 
   existence(bl,4),
  succeeds moves(?p,ms(?p)) by existence(ms,1),
  succeeds and_pos(?p),
  succeeds alpha_beta(?a,?b,?p,s(?n),bl(?a,?b,ms(?p),?n)),
  ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n) by uniqueness(ab,4)],
 ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n))
).

/** If the position p is an OR node, then <TT>ab/4 = al/4</TT>. */

:- lemma(ab:or_pos,
all [a,b,p,n]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) & succeeds or_pos(?p) =>
  ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds nat(?n) & succeeds or_pos(?p),
 [succeeds pos_list(ms(?p)) by lemma(ms:types),
  succeeds alpha_list(?a,?b,ms(?p),?n,al(?a,?b,ms(?p),?n)) by 
   existence(al,4),
  succeeds moves(?p,ms(?p)) by existence(ms,1),
  succeeds or_pos(?p),
  succeeds alpha_beta(?a,?b,?p,s(?n),al(?a,?b,ms(?p),?n)),
  ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n) by uniqueness(ab,4)],
 ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n))
).

/** If the positionlist is empty, then <TT>al/4 = alpha</TT>. */ 

:- lemma(al:empty,
all [a,b,n]: succeeds val(?a) & succeeds val(?b) & succeeds nat(?n) =>
  al(?a,?b,[],?n) = ?a,
assume(succeeds val(?a) & succeeds val(?b) & succeeds nat(?n),
 al(?a,?b,[],?n) = ?a by uniqueness(al,4),
 al(?a,?b,[],?n) = ?a)
).

/** If beta =< alpha, then <TT>al/4 = alpha</TT>. */

:- lemma(al:leq,
all [a,b,l,n]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?b #=< ?a =>
  al(?a,?b,?l,?n) = ?a,
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n) & succeeds ?b #=< ?a,
 al(?a,?b,?l,?n) = ?a by uniqueness(al,4),
 al(?a,?b,?l,?n) = ?a)
).

/** If alpha < beta, then <TT>al/4</TT> is computed recursively. */

:- lemma(al:cons,
all [a,b,p,l,n]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?a #< ?b =>
  al(?a,?b,[?p|?l],?n) = al(maxf(?a,ab(?a,?b,?p,?n)),?b,?l,?n),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?a #< ?b,
 [succeeds ?a #< ?b,
  succeeds alpha_beta(?a,?b,?p,?n,ab(?a,?b,?p,?n)) by existence(ab,4),
  succeeds val(ab(?a,?b,?p,?n)) by corollary(alpha_beta:types),
  succeeds max(?a,ab(?a,?b,?p,?n),maxf(?a,ab(?a,?b,?p,?n))) by 
   existence(maxf,2),
  def succeeds max(?a,ab(?a,?b,?p,?n),maxf(?a,ab(?a,?b,?p,?n))) by 
   completion,
  cases(succeeds ?a #=< ab(?a,?b,?p,?n) &
   maxf(?a,ab(?a,?b,?p,?n)) = ab(?a,?b,?p,?n),
   [],
   fails ?a #=< ab(?a,?b,?p,?n) & maxf(?a,ab(?a,?b,?p,?n)) = ?a,
   [],
   succeeds val(maxf(?a,ab(?a,?b,?p,?n)))),
  succeeds 
  alpha_list(maxf(?a,ab(?a,?b,?p,?n)),?b,?l,?n,
   al(maxf(?a,ab(?a,?b,?p,?n)),?b,?l,?n)) by existence(al,4),
  al(?a,?b,[?p|?l],?n) = al(maxf(?a,ab(?a,?b,?p,?n)),?b,?l,?n) by 
   uniqueness(al,4)],
 al(?a,?b,[?p|?l],?n) = al(maxf(?a,ab(?a,?b,?p,?n)),?b,?l,?n))
).

/** If the positionlist is empty, <TT>then bl/4 = beta</TT>. */

:- lemma(bl:empty,
all [a,b,n]: succeeds val(?a) & succeeds val(?b) & succeeds nat(?n) =>
  bl(?a,?b,[],?n) = ?b,
assume(succeeds val(?a) & succeeds val(?b) & succeeds nat(?n),
 bl(?a,?b,[],?n) = ?b by uniqueness(bl,4),
 bl(?a,?b,[],?n) = ?b)
).

/** If beta =< alpha, then <TT>bl/4 = beta</TT>. */ 

:- lemma(bl:leq,
all [a,b,l,n]: succeeds val(?a) & succeeds val(?b) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?b #=< ?a =>
  bl(?a,?b,?l,?n) = ?b,
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos_list(?l) &
 succeeds nat(?n) & succeeds ?b #=< ?a,
 bl(?a,?b,?l,?n) = ?b by uniqueness(bl,4),
 bl(?a,?b,?l,?n) = ?b)
).

/** If alpha < beta, then compute <TT>bl/4</TT> recursively. */

:- lemma(bl:cons,
all [a,b,p,l,n]: succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?a #< ?b =>
  bl(?a,?b,[?p|?l],?n) = bl(?a,minf(?b,ab(?a,?b,?p,?n)),?l,?n),
assume(succeeds val(?a) & succeeds val(?b) & succeeds pos(?p) &
 succeeds pos_list(?l) & succeeds nat(?n) & succeeds ?a #< ?b,
 [succeeds ?a #< ?b,
  succeeds alpha_beta(?a,?b,?p,?n,ab(?a,?b,?p,?n)) by existence(ab,4),
  succeeds val(ab(?a,?b,?p,?n)) by corollary(alpha_beta:types),
  succeeds min(?b,ab(?a,?b,?p,?n),minf(?b,ab(?a,?b,?p,?n))) by 
   existence(minf,2),
  def succeeds min(?b,ab(?a,?b,?p,?n),minf(?b,ab(?a,?b,?p,?n))) by 
   completion,
  cases(succeeds ?b #=< ab(?a,?b,?p,?n) & minf(?b,ab(?a,?b,?p,?n)) = ?b,
   [],
   fails ?b #=< ab(?a,?b,?p,?n) &
   minf(?b,ab(?a,?b,?p,?n)) = ab(?a,?b,?p,?n),
   [],
   succeeds val(minf(?b,ab(?a,?b,?p,?n)))),
  succeeds 
  beta_list(?a,minf(?b,ab(?a,?b,?p,?n)),?l,?n,
   bl(?a,minf(?b,ab(?a,?b,?p,?n)),?l,?n)) by existence(bl,4),
  bl(?a,?b,[?p|?l],?n) = bl(?a,minf(?b,ab(?a,?b,?p,?n)),?l,?n) by 
   uniqueness(bl,4)],
 bl(?a,?b,[?p|?l],?n) = bl(?a,minf(?b,ab(?a,?b,?p,?n)),?l,?n))
).

/** Some useful abbreviations. */

/** With these abbreviations you don't have to write complex formulas
on the sreen. The <TT>mon/3</TT> definition says that the three arguments
are ordered, in the sense of values. */

:- definition_pred(mon,3,
all [u,v,w]: mon(?u,?v,?w) <=> succeeds ?u #=< ?v & succeeds ?v #=< ?w
).

/** The predikate <TT>m1/1</TT> is an abbreviation for: if mon/3 is
true for mm/2, alpha and beta so 
<TT>ab/4 =< higher bound</TT>. */

:- definition_pred(m1,1,
all n: m1(?n) <=>
 (all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(mm(?p,?n),?a,?b) => succeeds ab(?a,?b,?p,?n) #=< ?a)
).

/** <TT>m2/1</TT> summarizes: If alpha, mm/2 and beta are 
ordered, then <TT>ab/4 = mm/2</TT>, called from the same position. */

:- definition_pred(m2,1,
all n: m2(?n) <=>
 (all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(?a,mm(?p,?n),?b) => ab(?a,?b,?p,?n) = mm(?p,?n))
).

/** <TT>m3/1</TT>: If alpha =< beta  =< mm/2, then 
<TT>beta =< ab/4</TT>. */

:- definition_pred(m3,1,
all n: m3(?n) <=>
 (all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(?a,?b,mm(?p,?n)) => succeeds ?b #=< ab(?a,?b,?p,?n))
).

/** <TT>b1/2</TT>: If mil/2 =< alpha =< beta, then <TT>bl/4 =< alpha</TT>. */

:- definition_pred(b1,2,
all [l,n]: b1(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(mil(?l,?n),?a,?b) => succeeds bl(?a,?b,?l,?n) #=< ?a)
).

/** <TT>b2/2</TT>: If alpha =< mil/2 =< beta, then <TT>bl/4 =< mil/2</TT>. */

:- definition_pred(b2,2,
all [l,n]: b2(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(?a,mil(?l,?n),?b) => bl(?a,?b,?l,?n) = mil(?l,?n))
).

/** <TT>b3/2</TT>: If alpha =< beta =< mil/2, then <TT>bl/4 = beta</TT>. */

:- definition_pred(b3,2,
all [l,n]: b3(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(?a,?b,mil(?l,?n)) => bl(?a,?b,?l,?n) = ?b)
).

/** <TT>a1/2</TT>: If mal/2 =< alpha =< beta, then <TT>al/4 = alpha</TT>. */

:- definition_pred(a1,2,
all [l,n]: a1(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(mal(?l,?n),?a,?b) => al(?a,?b,?l,?n) = ?a)
).

/** <TT>a2/2</TT>: If alpha =< mal/2 =< beta, then <TT>al/4 = mal/2</TT>. */

:- definition_pred(a2,2,
all [l,n]: a2(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(?a,mal(?l,?n),?b) => al(?a,?b,?l,?n) = mal(?l,?n))
).

/** <TT>a3/2</TT>: If alpha =< beta =< mal/2, then <TT>beta =< al/4</TT>. */

:- definition_pred(a3,2,
all [l,n]: a3(?l,?n) <=>
 (all [a,b]: succeeds val(?a) & succeeds val(?b) &
   mon(?a,?b,mal(?l,?n)) => succeeds ?b #=< al(?a,?b,?l,?n))
).

/** All following lemmas are needed to prove the <TT>lemma(pre:1)</TT>. */

/** If for all positionlist l, postions x and natural n m1(n) and b1(l,n)
succeed then <TT>b1+/2 = b1([x|l],n)</TT> succeeds. With other words:
If mm/2 =< a =< b and mil/2 =< a =< b then
ab/4 =< a and bl/4 =< a, from what follows mil([x|l],n) =< a =< b and
by elimination bl(a,b,[x|l],n) =< a =< b. */   

:- lemma(bet1:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m1(?n) & b1(?l,?n) => b1([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m1(?n) &
 b1(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(mil([?x|?l],?n),?a,?b),
   [succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
    /** We make a case splitting for the relation between two values.
    Case 1: lower bound < higher bound. */
    cases(succeeds ?a #< ?b,
      [succeeds mil([?x|?l],?n) #=< ?a & succeeds ?a #=< ?b by 
        elimination(mon,3),
       succeeds min_list([?x|?l],?n,mil([?x|?l],?n)) by existence(mil,2),
       succeeds pos_list([?x|?l]),
       succeeds val(mil([?x|?l],?n)) by corollary(min_list:types),
       succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
       succeeds val(mm(?x,?n)) by corollary(min_max:types),
       succeeds min_list(?l,?n,mil(?l,?n)) by existence(mil,2),
       succeeds val(mil(?l,?n)) by corollary(min_list:types),
       mil([?x|?l],?n) = minf(mm(?x,?n),mil(?l,?n)) by lemma(mil:cons),
       succeeds min(mm(?x,?n),mil(?l,?n),minf(mm(?x,?n),mil(?l,?n))) by 
        existence(minf,2),
       succeeds min(mm(?x,?n),mil(?l,?n),mil([?x|?l],?n)),
       def succeeds min(mm(?x,?n),mil(?l,?n),mil([?x|?l],?n)) by 
	completion,
       cases(succeeds mm(?x,?n) #=< mil(?l,?n) &
	mil([?x|?l],?n) = mm(?x,?n),
	[],
	fails mm(?x,?n) #=< mil(?l,?n) & mil([?x|?l],?n) = mil(?l,?n),
	[],
	mil([?x|?l],?n) = mm(?x,?n) \/ mil([?x|?l],?n) = mil(?l,?n)),
       def succeeds min(mm(?x,?n),mil(?l,?n),mil([?x|?l],?n)) by 
	completion,
       cases(succeeds mm(?x,?n) #=< mil(?l,?n) &
	mil([?x|?l],?n) = mm(?x,?n),
	[],
	fails mm(?x,?n) #=< mil(?l,?n) & mil([?x|?l],?n) = mil(?l,?n),
	[],
	succeeds mm(?x,?n) #=< ?a \/ succeeds mil(?l,?n) #=< ?a),
       /** Case 1.1: mm/2 =< lower bound. */
       cases(succeeds mm(?x,?n) #=< ?a,
        [all [x,a,b]: succeeds pos(?x) & succeeds val(?a) & 
          succeeds val(?b) & mon(mm(?x,?n),?a,?b) => 
           succeeds ab(?a,?b,?x,?n) #=< ?a by elimination(m1,1),
         succeeds mm(?x,?n) #=< ?a & succeeds ?a #=< ?b,
         mon(mm(?x,?n),?a,?b) by introduction(mon,3),
         succeeds ab(?a,?b,?x,?n) #=< ?a,
         succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) by 
          existence(ab,4),
         succeeds val(ab(?a,?b,?x,?n)) by corollary(alpha_beta:types), 
         succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
          existence(minf,2),
         def succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
	  completion,
	 cases(succeeds ?b #=< ab(?a,?b,?x,?n) &
	  minf(?b,ab(?a,?b,?x,?n)) = ?b,
	  [],
	  fails ?b #=< ab(?a,?b,?x,?n) &
	  minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
	  [],
	  succeeds val(minf(?b,ab(?a,?b,?x,?n)))),
          def succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by
	   completion,
	  cases(succeeds ?b #=< ab(?a,?b,?x,?n) &
	   minf(?b,ab(?a,?b,?x,?n)) = ?b,
	   [succeeds ab(?a,?b,?x,?n) #=< ?a,
	    succeeds ?a #=< ?b,
            succeeds ?b #=< ?a by axiom(value:leq:transitive),
            succeeds minf(?b,ab(?a,?b,?x,?n)) #=< ?a],
	   fails ?b #=< ab(?a,?b,?x,?n) &
	   minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
	   [],
	   succeeds minf(?b,ab(?a,?b,?x,?n)) #=< ?a),
          succeeds 
          beta_list(?a,minf(?b,ab(?a,?b,?x,?n)),?l,?n,
           bl(?a,minf(?b,ab(?a,?b,?x,?n)),?l,?n)) by existence(bl,4),
          succeeds minf(?b,ab(?a,?b,?x,?n)) #=< ?a,
         def succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
	  completion,
	 cases(succeeds ?b #=< ab(?a,?b,?x,?n) &
	  minf(?b,ab(?a,?b,?x,?n)) = ?b,
	  [],
	  fails ?b #=< ab(?a,?b,?x,?n) &
	  minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
	  [],
	  minf(?b,ab(?a,?b,?x,?n)) = ?b \/
	  minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n)), 
         /** Case 1.1.1: higher bound =< ab/4. */
	 cases(minf(?b,ab(?a,?b,?x,?n)) = ?b,
          [succeeds ?b #=< ?a,
	   succeeds beta_list(?a,?b,[?x|?l],?n,?b),
           bl(?a,?b,[?x|?l],?n) = ?b by lemma(bl:leq),
           succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
          /** Case 1.1.2: ab/4 =< higher bound. */
          minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
          [succeeds ab(?a,?b,?x,?n) #=< ?a,
           bl(?a,ab(?a,?b,?x,?n),?l,?n) = ab(?a,?b,?x,?n) by 
            lemma(bl:leq),
           succeeds bl(?a,ab(?a,?b,?x,?n),?l,?n) #=< ?a,
           succeeds ?a #< ?b,
           ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1),
           exist(v1,
            succeeds alpha_beta(?a,?b,?x,?n,?v1),
            [?v1 = ab(?a,?b,?x,?n) by corollary(alpha_beta:uniqueness),
	     succeeds ?v1 #=< ?a, 
             ex v2: succeeds min(?b,?v1,?v2) by lemma(min:existence),
             exist(v2,
              succeeds min(?b,?v1,?v2),
              [?v2 = minf(?b,?v1) by uniqueness(minf,2),
	       ?v2 = minf(?b,ab(?a,?b,?x,?n)),
               minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
               ?v2 = ab(?a,?b,?x,?n),
               succeeds ?v2 #=< ?a,
               ex v: succeeds beta_list(?a,?v2,?l,?n,?v) by 
                corollary(beta_list:existence),
               exist(v,
                succeeds beta_list(?a,?v2,?l,?n,?v),
                [succeeds bl(?a,?v2,?l,?n) #=< ?a,
		 succeeds beta_list(?a,?b,[?x|?l],?n,?v),
                 ?v = bl(?a,?v2,?l,?n) by uniqueness(bl,4),
                 ?v = bl(?a,?b,[?x|?l],?n) by uniqueness(bl,4),
                 bl(?a,?b,[?x|?l],?n) = bl(?a,?v2,?l,?n),
                 succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
                succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
              succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
            succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
          succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
        /** Case 1.2: mil/2 =< lower bound. */
        succeeds mil(?l,?n) #=< ?a,
        [succeeds mil(?l,?n) #=< ?a & succeeds ?a #=< ?b,
	 all [a,b]: succeeds val(?a) & succeeds val(?b) &
	  mon(mil(?l,?n),?a,?b) => succeeds bl(?a,?b,?l,?n) #=< ?a by 
	  elimination(b1,2),
	 succeeds ?a #< ?b,
         ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1) by 
          corollary(alpha_beta:existence),
         exist(v1,
          succeeds alpha_beta(?a,?b,?x,?n,?v1),
          [?v1 = ab(?a,?b,?x,?n) by uniqueness(ab,4),
	   succeeds val(?v1) by corollary(alpha_beta:types),
           ex v2: succeeds min(?b,?v1,?v2) by lemma(min:existence),
           exist(v2,
            succeeds min(?b,?v1,?v2),
            [?v2 = minf(?b,?v1) by uniqueness(minf,2),
	     def succeeds min(?b,?v1,?v2) by completion,
	     cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
	      [],
	      fails ?b #=< ?v1 & ?v2 = ?v1,
	      [],
	      succeeds val(?v2)),
             def succeeds min(?b,?v1,?v2) by completion,
	     cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
	      [],
	      fails ?b #=< ?v1 & ?v2 = ?v1,
	      [],
	      ?v2 = ?b \/ ?v2 = ?v1),
             cases(?v2 = ?b,
              [mon(mil(?l,?n),?a,?b) by introduction(mon,3),
	       succeeds bl(?a,?b,?l,?n) #=< ?a,
               ex v: succeeds beta_list(?a,?v2,?l,?n,?v) by 
                corollary(beta_list:existence),
               exist(v,
                succeeds beta_list(?a,?v2,?l,?n,?v),
                [succeeds beta_list(?a,?b,[?x|?l],?n,?v),
		 ?v = bl(?a,?v2,?l,?n) by uniqueness(bl,4),
                 ?v = bl(?a,?b,?l,?n),
                 succeeds ?v #=< ?a,
                 ?v = bl(?a,?b,[?x|?l],?n) by uniqueness(bl,4),
                 succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
                succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
              ?v2 = ?v1,
              [succeeds ?v2 #=< ?b \/ succeeds ?b #=< ?v2 by 
                axiom(value:leq:total),
	       cases(succeeds ?v2 #=< ?b,
                [],
                succeeds ?b #=< ?v2,
                [def succeeds min(?b,?v1,?v2) by completion,
                 cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
                  [],
                  fails ?b #=< ?v1 & ?v2 = ?v1,
                  [fails ?b #=< ?v2,
		   succeeds ?v2 #=< ?b],
                  succeeds ?v2 #=< ?b)],
                succeeds ?v2 #=< ?b),
               succeeds ?v2 #=< ?a \/ succeeds ?a #=< ?v2 by 
                axiom(value:leq:total),
               cases(succeeds ?v2 #=< ?a,
                [ex v: succeeds beta_list(?a,?v2,?l,?n,?v) by 
                  corollary(beta_list:existence),
		 exist(v,
                  succeeds beta_list(?a,?v2,?l,?n,?v),
                  [succeeds beta_list(?a,?v2,?l,?n,?v2),
                   ?v = ?v2 by corollary(beta_list:uniqueness),
		   succeeds beta_list(?a,?b,[?x|?l],?n,?v),
                   bl(?a,?b,[?x|?l],?n) = ?v2 by uniqueness(bl,4),
                   succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
                  succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
                succeeds ?a #=< ?v2,
                [mon(mil(?l,?n),?a,?v2) by introduction(mon,3),
		 succeeds bl(?a,?v2,?l,?n) #=< ?a,
                 ex v: succeeds beta_list(?a,?v2,?l,?n,?v) by 
                  corollary(beta_list:existence),
                 exist(v,
                  succeeds beta_list(?a,?v2,?l,?n,?v),
                  [succeeds beta_list(?a,?b,[?x|?l],?n,?v),
		   ?v = bl(?a,?v2,?l,?n) by uniqueness(bl,4),
                   ?v = bl(?a,?b,[?x|?l],?n) by uniqueness(bl,4),
                   succeeds ?v #=< ?a,
                   succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
                  succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
                succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
              succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
            succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
          succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
        succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
     /** Case 2: higher bound =< lower bound. */ 
     succeeds ?b #=< ?a,
     [succeeds beta_list(?a,?b,[?x|?l],?n,?b),
      bl(?a,?b,[?x|?l],?n) = ?b by lemma(bl:leq),
      succeeds bl(?a,?b,[?x|?l],?n) #=< ?a],
     succeeds bl(?a,?b,[?x|?l],?n) #=< ?a)],
   succeeds bl(?a,?b,[?x|?l],?n) #=< ?a),
  b1([?x|?l],?n) by introduction(b1,2)],
 b1([?x|?l],?n))
).

/** For any position list l, position x and natural l, if 
m2(n), m3(n), b2(l,n) and b3(l,n) succeed then succeeds 
<TT>b2+/2 = b2([x|l],n)</TT>.  */
 
:- lemma(bet2:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m3(?n) & m2(?n) & b2(?l,?n) & b3(?l,?n) 
  => b2([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m3(?n) &
 m2(?n) & b2(?l,?n) & b3(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(?a,mil([?x|?l],?n),?b),
   [succeeds pos_list([?x|?l]),
    succeeds min_list([?x|?l],?n,mil([?x|?l],?n)) by existence(mil,2),
    succeeds val(mil([?x|?l],?n)) by corollary(min_list:types),
    succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
    succeeds val(mm(?x,?n)) by corollary(min_max:types),
    succeeds min_list(?l,?n,mil(?l,?n)) by existence(mil,2),
    succeeds val(mil(?l,?n)) by corollary(min_list:types),
    succeeds min(mm(?x,?n),mil(?l,?n),minf(mm(?x,?n),mil(?l,?n))) by 
     existence(minf,2),
    mil([?x|?l],?n) = minf(mm(?x,?n),mil(?l,?n)) by uniqueness(mil,2),
    def succeeds min(mm(?x,?n),mil(?l,?n),minf(mm(?x,?n),mil(?l,?n))) by 
     completion,
    cases(succeeds mm(?x,?n) #=< mil(?l,?n) &
     minf(mm(?x,?n),mil(?l,?n)) = mm(?x,?n),
     [],
     fails mm(?x,?n) #=< mil(?l,?n) &
     minf(mm(?x,?n),mil(?l,?n)) = mil(?l,?n),
     [succeeds mil(?l,?n) #=< mm(?x,?n) by lemma(value:less:few),
      succeeds mm(?x,?n) #=< mil(?l,?n) & mil([?x|?l],?n) = mm(?x,?n) \/
      succeeds mil(?l,?n) #=< mm(?x,?n) & mil([?x|?l],?n) = mil(?l,?n)],
     succeeds mm(?x,?n) #=< mil(?l,?n) & mil([?x|?l],?n) = mm(?x,?n) \/
     succeeds mil(?l,?n) #=< mm(?x,?n) & mil([?x|?l],?n) = mil(?l,?n)),
    succeeds ?a #=< mil([?x|?l],?n) & succeeds mil([?x|?l],?n) #=< ?b by 
     elimination(mon,3),
    succeeds ?a #=< ?b by axiom(value:leq:transitive),
    succeeds ?a #< ?b \/ ?a = ?b by lemma(value:weak),
    /** Case 1: lower bound < higher bound. */
    cases(succeeds ?a #< ?b,
     [bl(?a,?b,[?x|?l],?n) = bl(?a,minf(?b,ab(?a,?b,?x,?n)),?l,?n) by 
       lemma(bl:cons),
      cases(succeeds mm(?x,?n) #=< mil(?l,?n) & mil([?x|?l],?n) = mm(?x,?n),
       [mon(?a,mm(?x,?n),?b),
	all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & 
	 succeeds val(?b) & mon(?a,mm(?p,?n),?b) => 
	  ab(?a,?b,?p,?n) = mm(?p,?n) by elimination(m2,1),
	ab(?a,?b,?x,?n) = mm(?x,?n),
        mon(?a,ab(?a,?b,?x,?n),?b),
        succeeds ?a #=< ab(?a,?b,?x,?n) & succeeds ab(?a,?b,?x,?n) #=< ?b by
	 elimination(mon,3),
	succeeds ab(?a,?b,?x,?n) #=< ?b,
        succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
         existence(minf,2),
        def succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
	 completion,
	cases(succeeds ?b #=< ab(?a,?b,?x,?n) &
	 minf(?b,ab(?a,?b,?x,?n)) = ?b,
	 [succeeds ab(?a,?b,?x,?n) #=< ?b,
          ?b = ab(?a,?b,?x,?n) by axiom(value:leq:antisymmetric),
	  succeeds min(?b,ab(?a,?b,?x,?n),ab(?a,?b,?x,?n))],
	 fails ?b #=< ab(?a,?b,?x,?n) &
	 minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
	 [],
	 succeeds min(?b,ab(?a,?b,?x,?n),ab(?a,?b,?x,?n))),
	minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n) by uniqueness(minf,2),
        bl(?a,?b,[?x|?l],?n) = bl(?a,ab(?a,?b,?x,?n),?l,?n),
        succeeds ab(?a,?b,?x,?n) #=< ?a \/ succeeds ?a #=< ab(?a,?b,?x,?n),
        /** Case 1.1: ab/4 =< lower bound. */
        cases(succeeds ab(?a,?b,?x,?n) #=< ?a,
         [bl(?a,ab(?a,?b,?x,?n),?l,?n) = ab(?a,?b,?x,?n) by lemma(bl:leq),
	  bl(?a,?b,[?x|?l],?n) = bl(?a,ab(?a,?b,?x,?n),?l,?n),
          bl(?a,?b,[?x|?l],?n) = ab(?a,?b,?x,?n),
          bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)],
         /** Case 1.2: lower bound =< ab/4.*/
         succeeds ?a #=< ab(?a,?b,?x,?n),
         [succeeds mm(?x,?n) #=< mil(?l,?n),
          succeeds ?a #=< mm(?x,?n),
          succeeds ?a #=< mil(?l,?n) by axiom(value:leq:transitive),
	  succeeds ab(?a,?b,?x,?n) #=< mil(?l,?n),
          mon(?a,ab(?a,?b,?x,?n),mil(?l,?n)) by introduction(mon,3),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(?a,?b,mil(?l,?n)) => bl(?a,?b,?l,?n) = ?b by 
	   elimination(b3,2),
	  bl(?a,ab(?a,?b,?x,?n),?l,?n) = ab(?a,?b,?x,?n),
          bl(?a,?b,[?x|?l],?n) = bl(?a,ab(?a,?b,?x,?n),?l,?n),
          bl(?a,?b,[?x|?l],?n) = ab(?a,?b,?x,?n),
          bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)],
         bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n))],
       succeeds mil(?l,?n) #=< mm(?x,?n) & mil([?x|?l],?n) = mil(?l,?n),
       [mon(?a,mil(?l,?n),?b),
        mon(?a,mil(?l,?n),mm(?x,?n)) by introduction(mon,3),
	all [a,b]: succeeds val(?a) & succeeds val(?b) &
	 mon(?a,mil(?l,?n),?b) => bl(?a,?b,?l,?n) = mil(?l,?n) by 
	 elimination(b2,2),
	bl(?a,?b,?l,?n) = mil(?l,?n),
        succeeds ?a #=< mil(?l,?n),
        succeeds ?a #=< mm(?x,?n) by axiom(value:leq:transitive),
        succeeds mm(?x,?n) #=< ?b \/ succeeds ?b #=< mm(?x,?n) by 
         axiom(value:leq:total),
        /** Case 1.3: mm/2 =< higher bound. */
        cases(succeeds mm(?x,?n) #=< ?b,
         [mon(?a,mm(?x,?n),?b) by introduction(mon,3),
	  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	   succeeds val(?b) & mon(?a,mm(?p,?n),?b) => 
	    ab(?a,?b,?p,?n) = mm(?p,?n) by elimination(m2,1),
	  ab(?a,?b,?x,?n) = mm(?x,?n),
          succeeds ab(?a,?b,?x,?n) #=< ?b,
          succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
           existence(minf,2),
          def succeeds min(?b,ab(?a,?b,?x,?n),minf(?b,ab(?a,?b,?x,?n))) by 
	   completion,
	  cases(succeeds ?b #=< ab(?a,?b,?x,?n) &
	   minf(?b,ab(?a,?b,?x,?n)) = ?b,
	   [succeeds ab(?a,?b,?x,?n) #=< ?b,
            ?b = ab(?a,?b,?x,?n) by axiom(value:leq:antisymmetric),
	    succeeds min(?b,ab(?a,?b,?x,?n),ab(?a,?b,?x,?n))],
	   fails ?b #=< ab(?a,?b,?x,?n) &
	   minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
	   [],
	   succeeds min(?b,ab(?a,?b,?x,?n),ab(?a,?b,?x,?n))),
	  minf(?b,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n) by uniqueness(minf,2),
          bl(?a,?b,[?x|?l],?n) = bl(?a,ab(?a,?b,?x,?n),?l,?n),
          mon(?a,mil(?l,?n),ab(?a,?b,?x,?n)),
          succeeds val(ab(?a,?b,?x,?n)),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(?a,mil(?l,?n),?b) => bl(?a,?b,?l,?n) = mil(?l,?n) by 
	   elimination(b2,2),
	  bl(?a,ab(?a,?b,?x,?n),?l,?n) = mil(?l,?n),
          bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)],
         /** Case 1.4: higher bound =< mm/2. */
         succeeds ?b #=< mm(?x,?n),
         [mon(?a,?b,mm(?x,?n)) by introduction(mon,3),
	  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	   succeeds val(?b) & mon(?a,?b,mm(?p,?n)) => 
	    succeeds ?b #=< ab(?a,?b,?p,?n) by elimination(m3,1),
	  succeeds ?b #=< ab(?a,?b,?x,?n),
	  mon(?a,?b,ab(?a,?b,?x,?n)) by introduction(mon,3),
          succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) by 
           existence(ab,4),
          succeeds val(ab(?a,?b,?x,?n)) by corollary(alpha_beta:types),
	  minf(?b,ab(?a,?b,?x,?n)) = ?b by uniqueness(minf,2),
          bl(?a,?b,?l,?n) = mil(?l,?n),
          bl(?a,?b,[?x|?l],?n) = bl(?a,?b,?l,?n),
          bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)],
         bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n))],
       bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n))],
     /** Case 2: lower bound = higher bound. */
     ?a = ?b,
     [succeeds ?a #=< ?b & succeeds ?b #=< ?a,
      succeeds ?b #=< ?a,
      bl(?a,?b,[?x|?l],?n) = ?b by lemma(bl:leq),
      mil([?x|?l],?n) = ?b by axiom(value:leq:antisymmetric),
      bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)],
     bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n))],
   bl(?a,?b,[?x|?l],?n) = mil([?x|?l],?n)),
  b2([?x|?l],?n) by introduction(b2,2)],
 b2([?x|?l],?n))
).

/** For all positionlist l, position x and natural n, if 
m3(n) and b3(l,n) succeed then succeeds <TT>b3+/2 = b3([x|l],n)</TT>. */

:- lemma(bet3:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m3(?n) & b3(?l,?n) => b3([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m3(?n) &
 b3(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(?a,?b,mil([?x|?l],?n)),
    [succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
     /** Case 1: lower bound < higher bound. */ 
     cases(succeeds ?a #< ?b,
      [succeeds pos_list([?x|?l]),
       succeeds min_list([?x|?l],?n,mil([?x|?l],?n)) by existence(mil,2),
       succeeds val(mil([?x|?l],?n)) by corollary(min_list:types),
       succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
       succeeds val(mm(?x,?n)) by corollary(min_max:types),
       succeeds min_list(?l,?n,mil(?l,?n)) by existence(mil,2),
       succeeds val(mil(?l,?n)) by corollary(min_list:types),
       succeeds min(mm(?x,?n),mil(?l,?n),minf(mm(?x,?n),mil(?l,?n))) by 
        existence(minf,2),
       mil([?x|?l],?n) = minf(mm(?x,?n),mil(?l,?n)) by uniqueness(mil,2),
       succeeds ?a #=< ?b & succeeds ?b #=< mil([?x|?l],?n) by 
	elimination(mon,3),
       succeeds ?b #=< minf(mm(?x,?n),mil(?l,?n)),
       def succeeds min(mm(?x,?n),mil(?l,?n),minf(mm(?x,?n),mil(?l,?n))) by
	completion,
       cases(succeeds mm(?x,?n) #=< mil(?l,?n) &
	minf(mm(?x,?n),mil(?l,?n)) = mm(?x,?n),
	[succeeds ?b #=< minf(mm(?x,?n),mil(?l,?n)),
         succeeds ?b #=< mm(?x,?n),
         succeeds mm(?x,?n) #=< mil(?l,?n),
	 succeeds ?b #=< mil(?l,?n) by axiom(value:leq:transitive)],
	fails mm(?x,?n) #=< mil(?l,?n) &
	minf(mm(?x,?n),mil(?l,?n)) = mil(?l,?n),
	[succeeds ?b #=< minf(mm(?x,?n),mil(?l,?n)),
         succeeds ?b #=< mil(?l,?n),
         succeeds mil(?l,?n) #=< mm(?x,?n) by lemma(value:less:few),
         succeeds ?b #=< mm(?x,?n) by axiom(value:leq:transitive)],
	succeeds ?b #=< mm(?x,?n) & succeeds ?b #=< mil(?l,?n)),
        mon(?a,?b,mm(?x,?n)) by introduction(mon,3),
        mon(?a,?b,mil(?l,?n)) by introduction(mon,3),
       succeeds ?a #< ?b,
       ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1) by 
        corollary(alpha_beta:existence),
       exist(v1,
        succeeds alpha_beta(?a,?b,?x,?n,?v1),
        [succeeds val(?v1) by corollary(alpha_beta:types),
	 ?v1 = ab(?a,?b,?x,?n) by uniqueness(ab,4),
         all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	  succeeds val(?b) & mon(?a,?b,mm(?p,?n)) => 
	   succeeds ?b #=< ab(?a,?b,?p,?n) by elimination(m3,1),
	 succeeds ?b #=< ab(?a,?b,?x,?n),
         succeeds ?b #=< ?v1, 
         ex v2: succeeds min(?b,?v1,?v2) by lemma(min:existence),
         exist(v2,
          succeeds min(?b,?v1,?v2),
          [def succeeds min(?b,?v1,?v2) by completion,
	   cases(succeeds ?b #=< ?v1 & ?v2 = ?b,
	    [],
	    fails ?b #=< ?v1 & ?v2 = ?v1,
	    [],
	    ?v2 = ?b),
	   ex v: succeeds beta_list(?a,?v2,?l,?n,?v) by 
            corollary(beta_list:existence),
           exist(v,
            succeeds beta_list(?a,?v2,?l,?n,?v),
            [succeeds beta_list(?a,?b,?l,?n,?v),
	     ?v = bl(?a,?b,?l,?n) by uniqueness(bl,4),
             all [a,b]: succeeds val(?a) & succeeds val(?b) &
	      mon(?a,?b,mil(?l,?n)) => bl(?a,?b,?l,?n) = ?b by 
	      elimination(b3,2),
	     bl(?a,?b,?l,?n) = ?b,
             succeeds beta_list(?a,?b,[?x|?l],?n,?v),
             ?v = bl(?a,?b,[?x|?l],?n) by uniqueness(bl,4),
             ?v = ?b,
             succeeds beta_list(?a,?b,[?x|?l],?n,?b)],
            succeeds beta_list(?a,?b,[?x|?l],?n,?b))],
          succeeds beta_list(?a,?b,[?x|?l],?n,?b))],
        succeeds beta_list(?a,?b,[?x|?l],?n,?b))],
      /** Case 2: higher bound =< lower bound. */
      succeeds ?b #=< ?a,
      [],
      succeeds beta_list(?a,?b,[?x|?l],?n,?b)),
     bl(?a,?b,[?x|?l],?n) = ?b by uniqueness(bl,4)],
   bl(?a,?b,[?x|?l],?n) = ?b),
  b3([?x|?l],?n) by introduction(b3,2)],
 b3([?x|?l],?n))
).

/** For all position list l, position x and natural n, if
m1(n) and a1(l,n) succeeds, then succeeds <TT>a1+/2 = a1([x|l],n)</TT>. */

:- lemma(ap1:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m1(?n) & a1(?l,?n) => a1([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m1(?n) &
 a1(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(mal([?x|?l],?n),?a,?b),
   [succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
    /** Case 1: lower bound < higher bound. */
    cases(succeeds ?a #< ?b,
     [succeeds mal([?x|?l],?n) #=< ?a & succeeds ?a #=< ?b by 
       elimination(mon,3),
      succeeds pos_list([?x|?l]),
      succeeds max_list([?x|?l],?n,mal([?x|?l],?n)) by existence(mal,2),
      succeeds val(mal([?x|?l],?n)) by corollary(max_list:types),
      succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
      succeeds val(mm(?x,?n)) by corollary(min_max:types),
      succeeds max_list(?l,?n,mal(?l,?n)) by existence(mal,2),
      succeeds val(mal(?l,?n)) by corollary(max_list:types),
      succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by 
       existence(maxf,2),
      mal([?x|?l],?n) = maxf(mm(?x,?n),mal(?l,?n)) by lemma(mal:cons),
      succeeds maxf(mm(?x,?n),mal(?l,?n)) #=< ?a,
      def succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by
       completion,
      cases(succeeds mm(?x,?n) #=< mal(?l,?n) &
       maxf(mm(?x,?n),mal(?l,?n)) = mal(?l,?n),
       [succeeds mal(?l,?n) #=< ?a, 
	succeeds mm(?x,?n) #=< ?a by axiom(value:leq:transitive)],
       fails mm(?x,?n) #=< mal(?l,?n) &
       maxf(mm(?x,?n),mal(?l,?n)) = mm(?x,?n),
       [succeeds mm(?x,?n) #=< ?a,
	succeeds mal(?l,?n) #=< mm(?x,?n) by lemma(value:less:few),
        succeeds mal(?l,?n) #=< ?a by axiom(value:leq:transitive)],
       succeeds mm(?x,?n) #=< ?a & succeeds mal(?l,?n) #=< ?a),
      succeeds mm(?x,?n) #=< ?a & succeeds ?a #=< ?b,
      succeeds mal(?l,?n) #=< ?a & succeeds ?a #=< ?b,
      all [x,a,b]: succeeds pos(?x) & succeeds val(?a) & succeeds val(?b) &
       mon(mm(?x,?n),?a,?b) => succeeds ab(?a,?b,?x,?n) #=< ?a by 
       elimination(m1,1),
      mon(mm(?x,?n),?a,?b) by introduction(mon,3),
      succeeds ab(?a,?b,?x,?n) #=< ?a,
      succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) by existence(ab,4),
      succeeds val(ab(?a,?b,?x,?n)) by corollary(alpha_beta:types),
      succeeds ab(?a,?b,?x,?n) #=< ?a,
      succeeds max(?a,ab(?a,?b,?x,?n),maxf(?a,ab(?a,?b,?x,?n))) by 
       existence(maxf,2),
      def succeeds max(?a,ab(?a,?b,?x,?n),maxf(?a,ab(?a,?b,?x,?n))) by 
       completion,
      cases(succeeds ?a #=< ab(?a,?b,?x,?n) &
       maxf(?a,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n),
       [?a = ab(?a,?b,?x,?n) by axiom(value:leq:antisymmetric),
	maxf(?a,ab(?a,?b,?x,?n)) = ?a],
       fails ?a #=< ab(?a,?b,?x,?n) & maxf(?a,ab(?a,?b,?x,?n)) = ?a,
       [],
       maxf(?a,ab(?a,?b,?x,?n)) = ?a),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(mal(?l,?n),?a,?b) => al(?a,?b,?l,?n) = ?a by elimination(a1,2),
      succeeds mal(?l,?n) #=< ?a & succeeds ?a #=< ?b,
      mon(mal(?l,?n),?a,?b) by introduction(mon,3),
      al(?a,?b,?l,?n) = ?a,
      succeeds alpha_list(?a,?b,?l,?n,al(?a,?b,?l,?n)) by existence(al,4),
      succeeds alpha_list(?a,?b,?l,?n,?a),
      succeeds ?a #< ?b & succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) &
      succeeds max(?a,ab(?a,?b,?x,?n),maxf(?a,ab(?a,?b,?x,?n))) &
      succeeds alpha_list(?a,?b,?l,?n,al(?a,?b,?l,?n)),
      ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1),
      exist(v1,
       succeeds alpha_beta(?a,?b,?x,?n,?v1),
       [?v1 = ab(?a,?b,?x,?n) by corollary(alpha_beta:uniqueness),
	ex v2: succeeds max(?a,?v1,?v2) by lemma(max:existence),
        exist(v2,
         succeeds max(?a,?v1,?v2),
         [?v2 = maxf(?a,?v1) by uniqueness(maxf,2),
          ?v2 = maxf(?a,ab(?a,?b,?x,?n)),
          ?v2 = ?a,
	  ex v: succeeds alpha_list(?v2,?b,?l,?n,?v) by 
           corollary(alpha_list:existence),
          exist(v,
           succeeds alpha_list(?v2,?b,?l,?n,?v),
           [succeeds alpha_list(?a,?b,[?x|?l],?n,?v),
	    ?v = al(?v2,?b,?l,?n) by corollary(alpha_list:uniqueness),
            ?v = al(?a,?b,?l,?n),
            succeeds alpha_list(?a,?b,[?x|?l],?n,al(?a,?b,?l,?n))],
           succeeds alpha_list(?a,?b,[?x|?l],?n,al(?a,?b,?l,?n)))],
         succeeds alpha_list(?a,?b,[?x|?l],?n,al(?a,?b,?l,?n)))],
       succeeds alpha_list(?a,?b,[?x|?l],?n,al(?a,?b,?l,?n))),
      succeeds alpha_list(?a,?b,[?x|?l],?n,?a),
      al(?a,?b,[?x|?l],?n) = ?a by uniqueness(al,4)],
     /** Case 2: higher bound =< lower bound. */
     succeeds ?b #=< ?a,
     al(?a,?b,[?x|?l],?n) = ?a by lemma(al:leq),
     al(?a,?b,[?x|?l],?n) = ?a)],
   al(?a,?b,[?x|?l],?n) = ?a),
  a1([?x|?l],?n) by introduction(a1,2)],
 a1([?x|?l],?n))
).

/** For all position list l, position x and natural n, if
m1(n), m2(n), a1(l,n) and a2(l,n) succeed, then succeeds 
<TT>a2+/2 = a2([x|l],n)</TT>. */ 

:- lemma(ap2:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m1(?n) & m2(?n) & a2(?l,?n) & a1(?l,?n) 
  => a2([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m1(?n) &
 m2(?n) & a2(?l,?n) & a1(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(?a,mal([?x|?l],?n),?b),
   [succeeds pos_list([?x|?l]),
    succeeds max_list([?x|?l],?n,mal([?x|?l],?n)) by existence(mal,2),
    succeeds val(mal([?x|?l],?n)) by corollary(max_list:types),
    succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
    succeeds val(mm(?x,?n)) by corollary(min_max:types),
    succeeds max_list(?l,?n,mal(?l,?n)) by existence(mal,2),
    succeeds val(mal(?l,?n)) by corollary(max_list:types),
    succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by 
     existence(maxf,2),
    mal([?x|?l],?n) = maxf(mm(?x,?n),mal(?l,?n)) by lemma(mal:cons),
    def succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by 
     completion,
    cases(succeeds mm(?x,?n) #=< mal(?l,?n) &
     maxf(mm(?x,?n),mal(?l,?n)) = mal(?l,?n),
     [],
     fails mm(?x,?n) #=< mal(?l,?n) &
     maxf(mm(?x,?n),mal(?l,?n)) = mm(?x,?n),
     [succeeds mal(?l,?n) #=< mm(?x,?n) by lemma(value:less:few),
      succeeds mal(?l,?n) #=< mm(?x,?n) & mal([?x|?l],?n) = mm(?x,?n) \/
      succeeds mm(?x,?n) #=< mal(?l,?n) & mal([?x|?l],?n) = mal(?l,?n)],
     succeeds mal(?l,?n) #=< mm(?x,?n) & mal([?x|?l],?n) = mm(?x,?n) \/
     succeeds mm(?x,?n) #=< mal(?l,?n) & mal([?x|?l],?n) = mal(?l,?n)),
    succeeds ?a #=< mal([?x|?l],?n) & succeeds mal([?x|?l],?n) #=< ?b by 
     elimination(mon,3),
    succeeds ?a #=< ?b by axiom(value:leq:transitive),
    succeeds ?a #< ?b \/ ?a = ?b by lemma(value:weak),
    /** Case 1: lower bound < higher bound. */
    cases(succeeds ?a #< ?b,
     [al(?a,?b,[?x|?l],?n) = al(maxf(?a,ab(?a,?b,?x,?n)),?b,?l,?n) by 
       lemma(al:cons),
      /** Case 1.1: mal/2 =< mm/2 and mal+/2 = mm/2, 
      mal+/2 = mal([x|l],n). */
      cases(succeeds mal(?l,?n) #=< mm(?x,?n) & mal([?x|?l],?n) = mm(?x,?n),
       [mon(?a,mm(?x,?n),?b),
	succeeds ?a #=< mm(?x,?n) & succeeds mm(?x,?n) #=< ?b by 
	 elimination(mon,3),
	succeeds mal(?l,?n) #=< ?b by axiom(value:leq:transitive),
        all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & 
	 succeeds val(?b) & mon(?a,mm(?p,?n),?b) => 
	  ab(?a,?b,?p,?n) = mm(?p,?n) by elimination(m2,1),
	ab(?a,?b,?x,?n) = mm(?x,?n),
        succeeds mal(?l,?n) #=< ab(?a,?b,?x,?n),
        succeeds ab(?a,?b,?x,?n) #=< ?b,
        maxf(?a,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n) by lemma(maxf:leq:1),
        al(?a,?b,[?x|?l],?n) = al(ab(?a,?b,?x,?n),?b,?l,?n),
        succeeds val(ab(?a,?b,?x,?n)),
        succeeds ?a #=< ab(?a,?b,?x,?n) \/ succeeds ab(?a,?b,?x,?n) #=< ?a,
        /** Case 1.1.1: lower bound =< ab/4. */
        cases(succeeds ?a #=< ab(?a,?b,?x,?n),
         [succeeds mal(?l,?n) #=< ?b,
	  mon(mal(?l,?n),ab(?a,?b,?x,?n),?b) by introduction(mon,3),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(mal(?l,?n),?a,?b) => al(?a,?b,?l,?n) = ?a by 
	   elimination(a1,2),
	  al(ab(?a,?b,?x,?n),?b,?l,?n) = ab(?a,?b,?x,?n),
          al(?a,?b,[?x|?l],?n) = ab(?a,?b,?x,?n),
          al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)],
         /** Case 1.1.2: ab/4 =< lower bound. */
         succeeds ab(?a,?b,?x,?n) #=< ?a,
         [ab(?a,?b,?x,?n) = ?a by axiom(value:leq:antisymmetric),
          mon(mal(?l,?n),ab(?a,?b,?x,?n),?b) by introduction(mon,3),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(mal(?l,?n),?a,?b) => al(?a,?b,?l,?n) = ?a by 
	   elimination(a1,2),
	  al(ab(?a,?b,?x,?n),?b,?l,?n) = ab(?a,?b,?x,?n),
          al(?a,?b,[?x|?l],?n) = ab(?a,?b,?x,?n),
	  al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)],
         al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n))],
       /** Case 1.2: mm/2 =< mal/2 and mal+/2 = mal/2. */
       succeeds mm(?x,?n) #=< mal(?l,?n) & mal([?x|?l],?n) = mal(?l,?n),
       [mon(?a,mal(?l,?n),?b),
	succeeds mal(?l,?n) #=< ?b,
        succeeds mm(?x,?n) #=< ?b by axiom(value:leq:transitive),
        succeeds ?a #=< mm(?x,?n) \/ succeeds mm(?x,?n) #=< ?a by 
         axiom(value:leq:total),
        /** Case 1.2.1: lower bound =< mm/2. */
        cases(succeeds ?a #=< mm(?x,?n),
         [mon(?a,mm(?x,?n),?b) by introduction(mon,3),
	  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	   succeeds val(?b) & mon(?a,mm(?p,?n),?b) => 
	    ab(?a,?b,?p,?n) = mm(?p,?n) by elimination(m2,1),
	  ab(?a,?b,?x,?n) = mm(?x,?n),
          mon(?a,ab(?a,?b,?x,?n),?b),
          succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) by 
           existence(ab,4),
          succeeds val(ab(?a,?b,?x,?n)) by corollary(alpha_beta:types),
          maxf(?a,ab(?a,?b,?x,?n)) = ab(?a,?b,?x,?n) by 
           lemma(maxf:leq:1),
          succeeds ab(?a,?b,?x,?n) #=< mal(?l,?n),
          mon(ab(?a,?b,?x,?n),mal(?l,?n),?b) by introduction(mon,3),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(?a,mal(?l,?n),?b) => al(?a,?b,?l,?n) = mal(?l,?n) by 
	   elimination(a2,2),
	  al(ab(?a,?b,?x,?n),?b,?l,?n) = mal(?l,?n),
          al(?a,?b,[?x|?l],?n) = al(ab(?a,?b,?x,?n),?b,?l,?n),
          al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)],
         /** Case 1.2.2: mm/2 =< lower bound. */
         succeeds mm(?x,?n) #=< ?a,
         [mon(mm(?x,?n),?a,?b) by introduction(mon,3),
	  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	   succeeds val(?b) & mon(mm(?p,?n),?a,?b) => 
	    succeeds ab(?a,?b,?p,?n) #=< ?a by elimination(m1,1),
	  succeeds ab(?a,?b,?x,?n) #=< ?a,
          succeeds alpha_beta(?a,?b,?x,?n,ab(?a,?b,?x,?n)) by 
           existence(ab,4),
          succeeds val(ab(?a,?b,?x,?n)) by corollary(alpha_beta:types),
          maxf(?a,ab(?a,?b,?x,?n)) = ?a by lemma(maxf:leq:2),
          al(?a,?b,[?x|?l],?n) = al(?a,?b,?l,?n),
          all [a,b]: succeeds val(?a) & succeeds val(?b) &
	   mon(?a,mal(?l,?n),?b) => al(?a,?b,?l,?n) = mal(?l,?n) by 
	   elimination(a2,2),
	  al(?a,?b,?l,?n) = mal(?l,?n),
          al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)],
         al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n))],
       al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n))],
     /** Case 2: lower bound = higher bound. */
     ?a = ?b,
     [succeeds ?b #=< ?a,
      mal([?x|?l],?n) = ?a by axiom(value:leq:antisymmetric),
      al(?a,?b,[?x|?l],?n) = ?a by lemma(al:leq),
      al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)],
     al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n))],
   al(?a,?b,[?x|?l],?n) = mal([?x|?l],?n)),
  a2([?x|?l],?n) by introduction(a2,2)],
 a2([?x|?l],?n))
).

/** For all positionlist l, position p and natural n, if
m3(n) and a3([x|l],n) succeed, then <TT>a3+/2 =  a3([x|l],n)</TT> succeeds. */

:- lemma(ap3:pn,
all [l,x,n]: succeeds pos_list(?l) & succeeds pos(?x) & 
 succeeds nat(?n) & m3(?n) & a3(?l,?n) => a3([?x|?l],?n),
assume(succeeds pos_list(?l) & succeeds pos(?x) & succeeds nat(?n) & m3(?n) &
 a3(?l,?n),
 [assume(succeeds val(?a) & succeeds val(?b) & mon(?a,?b,mal([?x|?l],?n)),
   [succeeds ?a #< ?b \/ succeeds ?b #=< ?a by lemma(value:lessleq),
    /** Case 1: lower bound < higher bound. */
    cases(succeeds ?a #< ?b,
     [succeeds ?a #=< ?b & succeeds ?b #=< mal([?x|?l],?n) by 
       elimination(mon,3),
      succeeds ?b #=< mal([?x|?l],?n),
      succeeds min_max(?x,?n,mm(?x,?n)) by existence(mm,2),
      succeeds val(mm(?x,?n)) by corollary(min_max:types),
      succeeds max_list(?l,?n,mal(?l,?n)) by existence(mal,2),
      succeeds val(mal(?l,?n)) by corollary(max_list:types),
      succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by 
       existence(maxf,2),
      mal([?x|?l],?n) = maxf(mm(?x,?n),mal(?l,?n)) by lemma(mal:cons),
      def succeeds max(mm(?x,?n),mal(?l,?n),maxf(mm(?x,?n),mal(?l,?n))) by
       completion,
      cases(succeeds mm(?x,?n) #=< mal(?l,?n) &
       maxf(mm(?x,?n),mal(?l,?n)) = mal(?l,?n),
       [],
       fails mm(?x,?n) #=< mal(?l,?n) &
       maxf(mm(?x,?n),mal(?l,?n)) = mm(?x,?n),
       [],
       mal([?x|?l],?n) = mm(?x,?n) \/ mal([?x|?l],?n) = mal(?l,?n)),
      /** Case 1.1: mal+/2 = mm/2. */
      cases(mal([?x|?l],?n) = mm(?x,?n),
       [succeeds ?a #=< ?b & succeeds ?b #=< mm(?x,?n), 
	mon(?a,?b,mm(?x,?n)),
        succeeds ?a #< ?b,
        ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1) by 
         corollary(alpha_beta:existence),
        exist(v1,
         succeeds alpha_beta(?a,?b,?x,?n,?v1),
         [succeeds val(?v1) by corollary(alpha_beta:types),
          ?v1 = ab(?a,?b,?x,?n) by uniqueness(ab,4),
	  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) &
	   succeeds val(?b) & mon(?a,?b,mm(?p,?n)) => 
	    succeeds ?b #=< ab(?a,?b,?p,?n) by elimination(m3,1),
	  mon(?a,?b,mm(?x,?n)),
          succeeds ?b #=< ab(?a,?b,?x,?n),
          succeeds ?b #=< ?v1,
          ex v2: succeeds max(?a,?v1,?v2) by lemma(max:existence),
          exist(v2,
           succeeds max(?a,?v1,?v2),
           [def succeeds max(?a,?v1,?v2) by completion,
	    cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
	     [],
	     fails ?a #=< ?v1 & ?v2 = ?a,
	     [succeeds ?v1 #=< ?a by lemma(value:less:few),
	      succeeds ?b #=< ?v1,
              succeeds ?a #=< ?b,
              succeeds ?b #=< ?a by axiom(value:leq:transitive),
              ?a = ?b by axiom(value:leq:antisymmetric),
              ?v2 = ?v1 by axiom(value:leq:antisymmetric)],
	     ?v2 = ?v1),
            ex v: succeeds alpha_list(?v2,?b,?l,?n,?v) by 
             corollary(alpha_list:existence),
            exist(v,
             succeeds alpha_list(?v2,?b,?l,?n,?v),
             [succeeds pos_list([?x|?l]),
              succeeds alpha_list(?a,?b,[?x|?l],?n,?v),
	      succeeds alpha_list(?v1,?b,?l,?n,?v),
              succeeds ?b #=< ?v1,
              succeeds alpha_list(?v1,?b,?l,?n,?v1),
              ?v = ?v1 by corollary(alpha_list:uniqueness),
              succeeds ?b #=< ?v,
              ?v = al(?a,?b,[?x|?l],?n) by uniqueness(al,4),
              succeeds ?b #=< al(?a,?b,[?x|?l],?n)],
             succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
           succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
         succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
       /** Case 1.2: mal+/2 = mal/2. */
       mal([?x|?l],?n) = mal(?l,?n),
       [mon(?a,?b,mal(?l,?n)),
	succeeds ?a #< ?b,
        ex v1: succeeds alpha_beta(?a,?b,?x,?n,?v1) by 
         corollary(alpha_beta:existence),
        exist(v1,
         succeeds alpha_beta(?a,?b,?x,?n,?v1),
         [succeeds val(?v1) by corollary(alpha_beta:types),
	  ?v1 = ab(?a,?b,?x,?n) by uniqueness(ab,4),
          ex v2: succeeds max(?a,?v1,?v2) by lemma(max:existence),
          exist(v2,
           succeeds max(?a,?v1,?v2),
           [def succeeds max(?a,?v1,?v2) by completion,
	    cases(succeeds ?a #=< ?v1 & ?v2 = ?v1,
	     [],
	     fails ?a #=< ?v1 & ?v2 = ?a,
	     [],
	     ?v2 = ?a \/ ?v2 = ?v1),
	    cases(?v2 = ?a,
             [ex v: succeeds alpha_list(?v2,?b,?l,?n,?v) by 
               corollary(alpha_list:existence),
	      exist(v,
               succeeds alpha_list(?v2,?b,?l,?n,?v),
               [succeeds alpha_list(?a,?b,[?x|?l],?n,?v),
		succeeds alpha_list(?a,?b,?l,?n,?v),
                ?v = al(?a,?b,?l,?n) by uniqueness(al,4),
                ?v = al(?a,?b,[?x|?l],?n) by uniqueness(al,4),
                mon(?a,?b,mal(?l,?n)),
                all [a,b]: succeeds val(?a) & succeeds val(?b) &
		 mon(?a,?b,mal(?l,?n)) => succeeds ?b #=< al(?a,?b,?l,?n) by
		 elimination(a3,2),
		 succeeds ?b #=< al(?a,?b,?l,?n),
                 succeeds ?b #=< ?v,
                succeeds ?b #=< al(?a,?b,[?x|?l],?n)],
               succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
             ?v2 = ?v1,
             [succeeds ?v1 #=< ?b \/ succeeds ?b #=< ?v1 by 
               axiom(value:leq:total),
	      cases(succeeds ?v1 #=< ?b,
               [ex v: succeeds alpha_list(?v2,?b,?l,?n,?v) by 
                 corollary(alpha_list:existence),
		exist(v,
                 succeeds alpha_list(?v2,?b,?l,?n,?v),
                 [succeeds pos_list([?x|?l]),
                  succeeds alpha_list(?a,?b,[?x|?l],?n,?v),
		  succeeds alpha_list(?v1,?b,?l,?n,?v),
                  ?v = al(?v1,?b,?l,?n) by uniqueness(al,4),
                  ?v = al(?a,?b,[?x|?l],?n) by uniqueness(al,4),
                  mon(?v1,?b,mal(?l,?n)) by introduction(mon,3),
                  all [a,b]: succeeds val(?a) & succeeds val(?b) &
		   mon(?a,?b,mal(?l,?n)) => 
		    succeeds ?b #=< al(?a,?b,?l,?n) by elimination(a3,2),
		  succeeds ?b #=< al(?v1,?b,?l,?n),
                  succeeds ?b #=< ?v,
                  succeeds ?b #=< al(?a,?b,[?x|?l],?n)],
                 succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
               succeeds ?b #=< ?v1,
               [ex v: succeeds alpha_list(?v2,?b,?l,?n,?v) by 
                 corollary(alpha_list:existence),
                exist(v,
                 succeeds alpha_list(?v2,?b,?l,?n,?v),
                 [succeeds pos_list([?x|?l]),
                  succeeds alpha_list(?a,?b,[?x|?l],?n,?v),
                  succeeds alpha_list(?v1,?b,?l,?n,?v),
                  succeeds alpha_list(?v1,?b,?l,?n,?v1),
		  ?v = ?v1 by corollary(alpha_list:uniqueness),
                  ?v = al(?a,?b,[?x|?l],?n) by uniqueness(al,4),
                  ?v1 = al(?a,?b,[?x|?l],?n) by uniqueness(al,4),
                  succeeds ?b #=< ?v1,
                  succeeds ?b #=< al(?a,?b,[?x|?l],?n)],
                 succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
               succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
             succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
           succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
         succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
       succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
     /** Case 2: higher bound =< lower bound. */
     succeeds ?b #=< ?a,
     [al(?a,?b,[?x|?l],?n) = ?a by lemma(al:leq),
      succeeds ?b #=< al(?a,?b,[?x|?l],?n)],
     succeeds ?b #=< al(?a,?b,[?x|?l],?n))],
   succeeds ?b #=< al(?a,?b,[?x|?l],?n)),
  a3([?x|?l],?n) by introduction(a3,2)],
 a3([?x|?l],?n))
).

/** As we mentioned it before, the preceeding six lemmas we need to
prove following lemma which says:
For all positionlist l and natural n, if m1(n), m2(n) and m3(n) succeed,
then b1(l,n), b2(l,n), b3(l,n), a1(l,n), a2(l,n) and a3(l,n) succeed. */

:- lemma(pre:abl,
all [l,n]: succeeds pos_list(?l) & succeeds nat(?n) &
 m1(?n) & m2(?n) & m3(?n) =>
  b1(?l,?n) & b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
/** We prove that statement by induction on the length of the 
position list l. */
[induction(
  [all l: succeeds pos_list(?l) => 
     (all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1(?l,?n) &
        b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n))],
  /** I([]): l= [] (the position list is empty). */ 
  [step([],
    [],
    assume(succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
     [assume(succeeds val(?a) & succeeds val(?b) & mon(mil([],?n),?a,?b),
       [succeeds mil([],?n) #=< ?a & succeeds ?a #=< ?b by 
         elimination(mon,3),
        mil([],?n) = top by lemma(mil:empty),
        succeeds val(top) by axiom(value:top),
        succeeds top #=< ?a,
        succeeds ?a #=< top by axiom(value:leq:top),
        top = ?a by axiom(value:leq:antisymmetric),
        succeeds beta_list(?a,?b,[],?n,bl(?a,?b,[],?n)) by existence(bl,4),
        def succeeds beta_list(?a,?b,[],?n,bl(?a,?b,[],?n)) by completion,
	succeeds val(bl(?a,?b,[],?n)),
        succeeds bl(?a,?b,[],?n) #=< top by axiom(value:leq:top),
        succeeds bl(?a,?b,[],?n) #=< ?a],
       succeeds bl(?a,?b,[],?n) #=< ?a),
      b1([],?n) by introduction(b1,2),
      assume(succeeds val(?a) & succeeds val(?b) & mon(?a,mil([],?n),?b),
       [succeeds ?a #=< mil([],?n) & succeeds mil([],?n) #=< ?b by 
         elimination(mon,3),
        succeeds min_list([],?n,mil([],?n)) by existence(mil,2),
        mil([],?n) = top by lemma(mil:empty),
        succeeds val(top) by axiom(value:top),
        succeeds top #=< ?b,
        succeeds ?b #=< top by axiom(value:leq:top),
        top = ?b by axiom(value:leq:antisymmetric),
        bl(?a,?b,[],?n) = ?b by lemma(bl:empty),
        bl(?a,?b,[],?n) = mil([],?n) by axiom(value:leq:antisymmetric)],
       bl(?a,?b,[],?n) = mil([],?n)),
      b2([],?n) by introduction(b2,2),
      assume(succeeds val(?a) & succeeds val(?b) & mon(?a,?b,mil([],?n)),
       [succeeds ?a #=< ?b & succeeds ?b #=< mil([],?n) by 
         elimination(mon,3),
        bl(?a,?b,[],?n) = ?b by lemma(bl:empty)],
       bl(?a,?b,[],?n) = ?b),
      b3([],?n) by introduction(b3,2),
      assume(succeeds val(?a) & succeeds val(?b) & mon(mal([],?n),?a,?b),
       [succeeds mal([],?n) #=< ?a & succeeds ?a #=< ?b by 
         elimination(mon,3),
        al(?a,?b,[],?n) = ?a by lemma(al:empty)],
       al(?a,?b,[],?n) = ?a),
      a1([],?n) by introduction(a1,2),
      assume(succeeds val(?a) & succeeds val(?b) & mon(?a,mal([],?n),?b),
       [succeeds ?a #=< mal([],?n) & succeeds mal([],?n) #=< ?b by 
         elimination(mon,3),
        mal([],?n) = bot by lemma(mal:empty),
        succeeds val(bot) by axiom(value:bot),
        succeeds ?a #=< bot,
        succeeds bot #=< ?a by axiom(value:leq:bot),
        bot = ?a by axiom(value:leq:antisymmetric),
        al(?a,?b,[],?n) = ?a by lemma(al:empty),
        al(?a,?b,[],?n) = mal([],?n) by axiom(value:leq:antisymmetric)],
       al(?a,?b,[],?n) = mal([],?n)),
      a2([],?n) by introduction(a2,2),
      assume(succeeds val(?a) & succeeds val(?b) & mon(?a,?b,mal([],?n)),
       [succeeds ?a #=< ?b & succeeds ?b #=< mal([],?n) by 
         elimination(mon,3),
       al(?a,?b,[],?n) = ?a by lemma(al:empty), 
       mal([],?n) = bot by uniqueness(mal,2),
       succeeds val(bot) by axiom(value:bot),
       succeeds ?b #=< bot,
       succeeds ?a #=< ?b,
       succeeds ?a #=< bot by axiom(value:leq:transitive),
       succeeds bot #=< ?a by axiom(value:leq:bot),
       ?a = bot by axiom(value:leq:antisymmetric),
       succeeds ?b #=< ?a,
       succeeds ?b #=< al(?a,?b,[],?n)],
       succeeds ?b #=< al(?a,?b,[],?n)),
      a3([],?n) by introduction(a3,2)],
     b1([],?n) & b2([],?n) & b3([],?n) & a1([],?n) & a2([],?n) & a3([],?n)),
    all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1([],?n) &
      b2([],?n) & b3([],?n) & a1([],?n) & a2([],?n) & a3([],?n)),
   /** Inductionstep I(l) to I([x|l]). Imagine you wold have to
   prove b1 to b3 and a1 to a3 here inside? */
   step([x,l],
    [all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1(?l,?n) &
       b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
     succeeds pos(?x),
     succeeds pos_list(?l)],
    assume(succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
     [all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1(?l,?n) &
       b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
      b1(?l,?n) & b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
      b1([?x|?l],?n) by lemma(bet1:pn),
      b2([?x|?l],?n) by lemma(bet2:pn),
      b3([?x|?l],?n) by lemma(bet3:pn),
      a1([?x|?l],?n) by lemma(ap1:pn),
      a2([?x|?l],?n) by lemma(ap2:pn),
      a3([?x|?l],?n) by lemma(ap3:pn)],
     b1([?x|?l],?n) & b2([?x|?l],?n) & b3([?x|?l],?n) & a1([?x|?l],?n) &
     a2([?x|?l],?n) & a3([?x|?l],?n)),
    all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1([?x|?l],?n) &
      b2([?x|?l],?n) & b3([?x|?l],?n) & a1([?x|?l],?n) & a2([?x|?l],?n) &
      a3([?x|?l],?n))]),
 assume(succeeds pos_list(?l) & succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
  [all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1(?l,?n) &
     b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
   succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => b1(?l,?n) & b2(?l,?n) &
    b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n),
   b1(?l,?n) & b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n)],
  b1(?l,?n) & b2(?l,?n) & b3(?l,?n) & a1(?l,?n) & a2(?l,?n) & a3(?l,?n))]
).

/** The following three lemmas are neede to prove <TT>theorem(main)</TT>. */

/** This lemma does the first third of the inductionstep I(n) to I(n+1)
in the main theorem. 
From m1(n), m2(n) and m3(n) follows <TT>m1(n+1)</TT>. */ 

:- lemma(test,
all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => m1(s(?n)),
assume(succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
 [assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(mm(?p,s(?n)),?a,?b),
   [succeeds moves(?p,ms(?p)) by existence(ms,1),
    succeeds pos_list(ms(?p)) by lemma(ms:types),
    b1(ms(?p),?n) & b2(ms(?p),?n) & b3(ms(?p),?n) & a1(ms(?p),?n) &
    a2(ms(?p),?n) & a3(ms(?p),?n) by lemma(pre:abl),
    succeeds and_pos(?p) \/ succeeds or_pos(?p) by axiom(pos:total),
    /** Case splitting on the kind of node you have.
    Case 1: p = AND node. */
    cases(succeeds and_pos(?p),
     [succeeds min_list(ms(?p),?n,mil(ms(?p),?n)) by existence(mil,2),
      succeeds val(mil(ms(?p),?n)) by corollary(min_list:types),
      mm(?p,s(?n)) = mil(ms(?p),?n) by lemma(mm:and_pos),
      mon(mil(ms(?p),?n),?a,?b),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(mil(ms(?p),?n),?a,?b) => succeeds bl(?a,?b,ms(?p),?n) #=< ?a by
       elimination(b1,2),
      succeeds bl(?a,?b,ms(?p),?n) #=< ?a,
      ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n) by lemma(ab:and_pos),
      succeeds ab(?a,?b,?p,s(?n)) #=< ?a],
     /** Case 2: p = OR node. */
     succeeds or_pos(?p),
     [succeeds max_list(ms(?p),?n,mal(ms(?p),?n)) by existence(mal,2),
      succeeds val(mal(ms(?p),?n)) by corollary(max_list:types),
      mm(?p,s(?n)) = mal(ms(?p),?n) by lemma(mm:or_pos),
      mon(mal(ms(?p),?n),?a,?b),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(mal(ms(?p),?n),?a,?b) => al(?a,?b,ms(?p),?n) = ?a by 
       elimination(a1,2),
      al(?a,?b,ms(?p),?n) = ?a,
      ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n) by lemma(ab:or_pos),
      ab(?a,?b,?p,s(?n)) = ?a,
      succeeds ab(?a,?b,?p,s(?n)) #=< ?a &
      succeeds ?a #=< ab(?a,?b,?p,s(?n)) by lemma(value:less:eq),
      succeeds ab(?a,?b,?p,s(?n)) #=< ?a],
     succeeds ab(?a,?b,?p,s(?n)) #=< ?a)],
   succeeds ab(?a,?b,?p,s(?n)) #=< ?a),
  m1(s(?n)) by introduction(m1,1)],
 m1(s(?n)))
).

/** Second third of the main theorem:
If m1(n), m2(n) and m3(n) are true, then <TT>m2(n+1)</TT> is true. */

:- lemma(fest,
all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => m2(s(?n)),
assume(succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
 [assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(?a,mm(?p,s(?n)),?b),
   [succeeds moves(?p,ms(?p)) by existence(ms,1),
    succeeds pos_list(ms(?p)) by lemma(ms:types),
    b1(ms(?p),?n) & b2(ms(?p),?n) & b3(ms(?p),?n) & a1(ms(?p),?n) &
    a2(ms(?p),?n) & a3(ms(?p),?n) by lemma(pre:abl),
    succeeds and_pos(?p) \/ succeeds or_pos(?p) by axiom(pos:total),
    /** Same procedure as in lemma(test).
    Case 1: p = AND node. */
    cases(succeeds and_pos(?p),
     [succeeds min_list(ms(?p),?n,mil(ms(?p),?n)) by existence(mil,2),
      succeeds val(mil(ms(?p),?n)) by corollary(min_list:types),
      mm(?p,s(?n)) = mil(ms(?p),?n) by lemma(mm:and_pos),
      mon(?a,mil(ms(?p),?n),?b),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(?a,mil(ms(?p),?n),?b) => bl(?a,?b,ms(?p),?n) = mil(ms(?p),?n) by
       elimination(b2,2),
      bl(?a,?b,ms(?p),?n) = mil(ms(?p),?n),
      ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n) by lemma(ab:and_pos),
      ab(?a,?b,?p,s(?n)) = mm(?p,s(?n))],
     /** Case 2: p = OR node. */
     succeeds or_pos(?p),
     [succeeds max_list(ms(?p),?n,mal(ms(?p),?n)) by existence(mal,2),
      succeeds val(mal(ms(?p),?n)) by corollary(max_list:types),
      mm(?p,s(?n)) = mal(ms(?p),?n) by lemma(mm:or_pos),
      mon(?a,mal(ms(?p),?n),?b),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(?a,mal(ms(?p),?n),?b) => al(?a,?b,ms(?p),?n) = mal(ms(?p),?n) by
       elimination(a2,2),
      al(?a,?b,ms(?p),?n) = mal(ms(?p),?n),
      ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n) by lemma(ab:or_pos),
      ab(?a,?b,?p,s(?n)) = mm(?p,s(?n))],
     ab(?a,?b,?p,s(?n)) = mm(?p,s(?n)))],
   ab(?a,?b,?p,s(?n)) = mm(?p,s(?n))),
  m2(s(?n)) by introduction(m2,1)],
 m2(s(?n)))
).

/** Final third for main theorem.
From m1(n), m2(n) and m3(n) follows <TT>m3(n+1)</TT>. */

:- lemma(rest,
all n: succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n) => m3(s(?n)),
assume(succeeds nat(?n) & m1(?n) & m2(?n) & m3(?n),
 [assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(?a,?b,mm(?p,s(?n))),
   [succeeds moves(?p,ms(?p)) by existence(ms,1),
    succeeds pos_list(ms(?p)) by lemma(ms:types),
    b1(ms(?p),?n) & b2(ms(?p),?n) & b3(ms(?p),?n) & a1(ms(?p),?n) &
    a2(ms(?p),?n) & a3(ms(?p),?n) by lemma(pre:abl),
    succeeds and_pos(?p) \/ succeeds or_pos(?p) by axiom(pos:total),
    /** Case 1: p = AND node. */
    cases(succeeds and_pos(?p),
     [succeeds min_list(ms(?p),?n,mil(ms(?p),?n)) by existence(mil,2),
      succeeds val(mil(ms(?p),?n)) by corollary(min_list:types),
      mm(?p,s(?n)) = mil(ms(?p),?n) by lemma(mm:and_pos),
      mon(?a,?b,mil(ms(?p),?n)),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(?a,?b,mil(ms(?p),?n)) => bl(?a,?b,ms(?p),?n) = ?b by 
       elimination(b3,2),
      bl(?a,?b,ms(?p),?n) = ?b,
      ab(?a,?b,?p,s(?n)) = bl(?a,?b,ms(?p),?n) by lemma(ab:and_pos),
      ab(?a,?b,?p,s(?n)) = ?b,
      succeeds ab(?a,?b,?p,s(?n)) #=< ?b &
      succeeds ?b #=< ab(?a,?b,?p,s(?n)) by lemma(value:less:eq),
      succeeds ?b #=< ab(?a,?b,?p,s(?n))],
     /** Case 2: p = OR node. */
     succeeds or_pos(?p),
     [succeeds max_list(ms(?p),?n,mal(ms(?p),?n)) by existence(mal,2),
      succeeds val(mal(ms(?p),?n)) by corollary(max_list:types),
      mm(?p,s(?n)) = mal(ms(?p),?n) by lemma(mm:or_pos),
      mon(?a,?b,mal(ms(?p),?n)),
      all [a,b]: succeeds val(?a) & succeeds val(?b) &
       mon(?a,?b,mal(ms(?p),?n)) => succeeds ?b #=< al(?a,?b,ms(?p),?n) by
       elimination(a3,2),
      succeeds ?b #=< al(?a,?b,ms(?p),?n),
      ab(?a,?b,?p,s(?n)) = al(?a,?b,ms(?p),?n) by lemma(ab:or_pos),
      succeeds ?b #=< ab(?a,?b,?p,s(?n))],
     succeeds ?b #=< ab(?a,?b,?p,s(?n)))],
   succeeds ?b #=< ab(?a,?b,?p,s(?n))),
  m3(s(?n)) by introduction(m3,1)],
 m3(s(?n)))
).

/** Proving equivalence between min_max/3 and alpha_beta/5 means
to find a bijection for the values returned by min_max/3 and
alpha_beta/5 for any position p. We introduced the predikates
<TT>m1/1, m2/1 & m3/1</TT> which do nothing else, than describe 
exactly that <TT>bijection</TT>. */

/** Now we prove by induction  on the natural n (depth of the
search tree) that those predikates are true. */ 

:- theorem(main,
all n: succeeds nat(?n) => m1(?n) & m2(?n) & m3(?n),
induction([all n: succeeds nat(?n) => m1(?n) & m2(?n) & m3(?n)],
 /** I(0): n = 0. */
 [step([],
   [],
   [assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
     mon(mm(?p,0),?a,?b),
     [succeeds mm(?p,0) #=< ?a & succeeds ?a #=< ?b by elimination(mon,3),
      mm(?p,0) = sv(?p) by lemma(mm:zero),
      succeeds sv(?p) #=< ?a,
      ab(?a,?b,?p,0) = sv(?p) by lemma(ab:zero),
      succeeds ab(?a,?b,?p,0) #=< ?a],
     succeeds ab(?a,?b,?p,0) #=< ?a),
    m1(0) by introduction(m1,1),
    assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
     mon(?a,mm(?p,0),?b),
     [mm(?p,0) = sv(?p) by lemma(mm:zero),
      ab(?a,?b,?p,0) = sv(?p) by lemma(ab:zero),
      ab(?a,?b,?p,0) = mm(?p,0)],
     ab(?a,?b,?p,0) = mm(?p,0)),
    m2(0) by introduction(m2,1),
    assume(succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
     mon(?a,?b,mm(?p,0)),
     [succeeds ?a #=< ?b & succeeds ?b #=< mm(?p,0) by elimination(mon,3),
      mm(?p,0) = sv(?p) by lemma(mm:zero),
      succeeds ?b #=< sv(?p),
      ab(?a,?b,?p,0) = sv(?p) by lemma(ab:zero),
      succeeds ?b #=< ab(?a,?b,?p,0)],
     succeeds ?b #=< ab(?a,?b,?p,0)),
    m3(0) by introduction(m3,1)],
   m1(0) & m2(0) & m3(0)),
  /** Inductionstep: I(n) to I(n+1). */
  step([x],
   [m1(?x) & m2(?x) & m3(?x),
    succeeds nat(?x)],
   [m1(s(?x)) by lemma(test),
    m2(s(?x)) by lemma(fest),
    m3(s(?x)) by lemma(rest)],
   m1(s(?x)) & m2(s(?x)) & m3(s(?x)))])
).

/** Now we found the bijection between the values returned by
min_max/3 and alpha_beta/5, we can follow easely for a given
intervall <TT>bot (=-infinity)</TT> to <TT>top (=+infimum)</TT> 
equality between <TT>mim_max/3 & alpha_beta/5</TT>. It follows directly from
the predikate <TT>m2/1</TT>. */ 

:- corollary(main,
all [p,n]: succeeds pos(?p) & succeeds nat(?n) =>
 ab(bot,top,?p,?n) = mm(?p,?n),
assume(succeeds pos(?p) & succeeds nat(?n),
 [succeeds val(bot) by axiom(value:bot),
  succeeds val(top) by axiom(value:top),
  m1(?n) & m2(?n) & m3(?n) by theorem(main),
  succeeds min_max(?p,?n,mm(?p,?n)) by existence(mm,2),
  succeeds val(mm(?p,?n)) by corollary(min_max:types),
  succeeds bot #=< mm(?p,?n) by axiom(value:leq:bot),
  succeeds mm(?p,?n) #=< top by axiom(value:leq:top),
  mon(bot,mm(?p,?n),top) by introduction(mon,3),
  succeeds val(bot) & succeeds val(top) & mon(bot,mm(?p,?n),top),
  all [p,a,b]: succeeds pos(?p) & succeeds val(?a) & succeeds val(?b) &
   mon(?a,mm(?p,?n),?b) => ab(?a,?b,?p,?n) = mm(?p,?n) by 
   elimination(m2,1),
  ab(bot,top,?p,?n) = mm(?p,?n)],
 ab(bot,top,?p,?n) = mm(?p,?n))
).

:- bye(alpha).

